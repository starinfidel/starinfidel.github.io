// Generated by Haxe 4.0.2
(function ($hx_exports, $global) { "use strict";
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var Cult = function(gvar,uivar,id,infoID) {
	this.game = gvar;
	this.ui = uivar;
	this.id = id;
	this.infoID = infoID;
	this.info = Static.cults[infoID];
	this.name = this.info.name;
	this.isAI = false;
	this.highlightedNodes = new haxe_ds_List();
	this.options = new Options(this.game,this.ui,this);
	this.isDiscovered = [];
	this.isInfoKnown = [];
	this.paralyzedTurns = 0;
	var _g = 0;
	var _g1 = this.game.difficulty.numCults;
	while(_g < _g1) {
		var i = _g++;
		this.isInfoKnown[i] = this.game.difficulty.isInfoKnown;
	}
	var _g2 = 0;
	var _g3 = this.game.difficulty.numCults;
	while(_g2 < _g3) {
		var i1 = _g2++;
		this.isDiscovered[i1] = this.game.difficulty.isDiscovered;
	}
	this.isDiscovered[id] = true;
	this.isInfoKnown[id] = true;
	this.power = [0,0,0,0];
	this.powerMod = [0,0,0,0];
	this.wars = [];
	var _g4 = 0;
	var _g5 = this.game.difficulty.numCults;
	while(_g4 < _g5) {
		var i2 = _g4++;
		this.wars.push(false);
	}
	this.adeptsUsed = 0;
	this.set_awareness(0);
	this.nodes = new haxe_ds_List();
	this.sects = new haxe_ds_List();
	this.investigatorTimeout = 0;
	this.difficulty = this.game.difficulty;
	this.logMessages = "";
	this.logPanelMessages = new haxe_ds_List();
};
Cult.__name__ = true;
Cult.prototype = {
	load: function(c) {
		this.difficulty = Static.difficulty[c.dif];
		this.isDead = c.ide;
		this.isParalyzed = c.ip;
		console.log("Cult.hx:108:","TODO load isDiscovered isInfoKnown");
		this.power = c.p;
		this.adeptsUsed = c.au;
		this.investigatorTimeout = c.it;
		if(c.inv != null) {
			this.hasInvestigator = true;
			this.investigator = new Investigator(this,this.ui,this.game);
			this.investigator.load(c.inv);
		}
		if(c.r != null) {
			this.isRitual = true;
			this.ritualPoints = c.rp;
			var _this = Static.rituals;
			var r = new haxe_ds__$StringMap_StringMapIterator(_this,_this.arrayKeys());
			while(r.hasNext()) {
				var r1 = r.next();
				if(r1.id == c.r) {
					this.ritual = r1;
				}
			}
		}
		this.set_awareness(c.aw);
		if(c.w != null) {
			var wlist = c.w;
			this.wars = [];
			var _g = 0;
			while(_g < wlist.length) {
				var w = wlist[_g];
				++_g;
				this.wars.push(w == 1);
			}
		}
	}
	,save: function() {
		console.log("Cult.hx:142:","TODO save isDiscovered isInfoKnown");
		var obj = { id : this.id, iid : this.infoID, dif : this.difficulty.level, ia : this.isAI ? 1 : 0, ide : this.isDead ? 1 : 0, ip : this.isParalyzed ? 1 : 0, p : this.power, or : this.origin != null ? this.origin.id : 0, au : this.adeptsUsed, it : this.investigatorTimeout};
		if(this.hasInvestigator) {
			obj.inv = this.investigator.save();
		}
		if(this.isRitual) {
			obj.r = this.ritual.id;
			obj.rp = this.ritualPoints;
		}
		obj.aw = this.awareness;
		var ww = [];
		var savewars = false;
		var _g = 0;
		var _g1 = this.wars;
		while(_g < _g1.length) {
			var w = _g1[_g];
			++_g;
			ww.push(w ? 1 : 0);
			if(w) {
				savewars = true;
			}
		}
		if(savewars) {
			obj.w = this.wars;
		}
		return obj;
	}
	,getMaxSects: function() {
		return this.nodes.length / 4 | 0;
	}
	,createSect: function(node) {
		if(this.sects.length >= (this.nodes.length / 4 | 0)) {
			return;
		}
		var sect = new sects_Sect(this.game,this.ui,node,this);
		this.sects.add(sect);
		node.sect = sect;
		node.update();
		if(!this.isAI) {
			this.ui.log2(this,node.name + " becomes the puppeteer of a sect called " + sect.name + ".",{ type : "sect", symbol : "s"});
		}
		if(!this.isAI) {
			this.game.tutorial.play("gainSect");
		}
	}
	,removeSect: function(node,src) {
		var text = node.sect.name;
		if(src == "investigator") {
			text += " has dispersed without proper inspiration.";
		} else if(src == "sacrifice") {
			text += " was sacrificed to discourage the investigator.";
		} else if(src == "attack") {
			text += " was disbanded when its puppeteer has left the cult.";
		} else if(src == "harvest") {
			text += " was harvested for resources.";
		}
		if(src != null) {
			this.ui.log2(this,text,{ type : "sect", symbol : "s"});
		}
		this.sects.remove(node.sect);
		node.sect.leader = null;
		node.sect = null;
		node.update();
	}
	,setOrigin: function() {
		if(this.game.difficulty.numCults == 4) {
			this.setupOriginFair();
		} else {
			this.setupOriginRandom();
		}
		this.origin.owner = this;
		if(!this.isAI || this.game.difficulty.isOriginKnown) {
			this.origin.isKnown[this.id] = true;
		}
		this.nodes.add(this.origin);
		this.origin.update();
		var _g = 0;
		var _g1 = Game.numPowers;
		while(_g < _g1) {
			var i = _g++;
			if(this.origin.power[i] > 0) {
				this.origin.powerGenerated[i] = 1;
				this.powerMod[i] += 1;
			}
		}
		this.origin.setGenerator(true);
		this.origin.setVisible(this,true);
		this.origin.showLinks();
		this.highlightedNodes.clear();
		var _g2 = 0;
		var _g3 = Game.numPowers;
		while(_g2 < _g3) {
			var i1 = _g2++;
			this.power[i1] += Math.round(this.origin.powerGenerated[i1]);
			if(Math.random() < 0.5) {
				this.origin.power[i1]++;
			}
		}
		this.origin.update();
		if(!this.isAI && this.game.difficultyLevel == 2) {
			this.removeCloseGenerators();
		}
	}
	,setupOriginFair: function() {
		var quad = this.game.freeQuadrants[Std.random(this.game.freeQuadrants.length)];
		HxOverrides.remove(this.game.freeQuadrants,quad);
		var tmp = [];
		var _g = 0;
		var _g1 = this.game.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			if(quad.x1 <= n.x && quad.y1 <= n.y && n.x <= quad.x2 && n.y <= quad.y2) {
				tmp.push(n);
			}
		}
		var node = tmp[Std.random(tmp.length)];
		this.origin = node;
	}
	,setupOriginRandom: function() {
		var index = -1;
		while(true) {
			index = Math.round((this.game.nodes.length - 1) * Math.random());
			var node = this.game.nodes[index];
			if(node.owner != null) {
				continue;
			}
			var ok = 1;
			var _g = 0;
			var _g1 = this.game.cults;
			while(_g < _g1.length) {
				var p = _g1[_g];
				++_g;
				if(p.origin != null && node.distance(p.origin) < this.difficulty.nodeActivationRadius + 50) {
					ok = 0;
					break;
				}
			}
			if(ok == 0) {
				continue;
			}
			this.origin = this.game.nodes[index];
			return;
		}
	}
	,removeCloseGenerators: function() {
		var _g_head = this.origin.links.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var n = val;
			if(n.owner == null && n.isGenerator) {
				n.setGenerator(false);
			}
		}
	}
	,set_awareness: function(v) {
		this.awareness = v;
		var _g = 0;
		var _g1 = this.game.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			if(n.visibility[this.id] && n.owner != this) {
				n.update();
			}
		}
		return v;
	}
	,getResourceChance: function() {
		var ch = 99 - (this.difficulty.awarenessResource * this.awareness | 0);
		if(ch < 1) {
			ch = 1;
		}
		return ch;
	}
	,getUpgradeChance: function(level) {
		var ch = 0;
		if(level == 0) {
			ch = 99 * this.difficulty.upgradeChance - this.awareness * this.difficulty.awarenessUpgrade | 0;
		} else if(level == 1) {
			ch = 80 * this.difficulty.upgradeChance - this.awareness * 1.5 * this.difficulty.awarenessUpgrade | 0;
		} else if(level == 2) {
			ch = 75 * this.difficulty.upgradeChance - this.awareness * 2 * this.difficulty.awarenessUpgrade | 0;
		}
		if(ch < 1) {
			ch = 1;
		}
		if(ch > 99) {
			ch = 99;
		}
		return ch;
	}
	,getGainChance: function(node) {
		var ch = 0;
		if(!node.isGenerator) {
			ch = 99 - (this.awareness * this.difficulty.awarenessGain | 0);
		} else {
			ch = 99 - (this.awareness * 2 * this.difficulty.awarenessGain | 0);
		}
		if(!this.isAI && node.owner != null && !node.owner.isInfoKnown[this.game.player.id]) {
			ch -= 20;
		}
		if(!this.isAI && node.owner != null && !node.isKnown[this.game.player.id]) {
			ch -= 10;
		}
		if(ch < 1) {
			ch = 1;
		}
		return ch;
	}
	,lowerAwareness: function(pwr) {
		if(this.awareness == 0 || this.adeptsUsed >= this.get_adepts() || pwr == 3) {
			return;
		}
		var _g = this;
		_g.set_awareness(_g.awareness - 2);
		if(this.awareness < 0) {
			this.set_awareness(0);
		}
		this.power[pwr]--;
		this.adeptsUsed++;
		if(!this.isAI) {
			this.ui.status.update();
			this.ui.map.paint();
		}
	}
	,getLowerWillChance: function() {
		var failChance = 30 * this.difficulty.investigatorWillpower;
		if(this.investigator.name == "Randolph Carter") {
			failChance += 10;
		}
		return 100 - failChance | 0;
	}
	,lowerWillpower: function(pwr) {
		if(!this.hasInvestigator || this.adeptsUsed >= this.get_adepts() || pwr == 3 || this.power[pwr] < Game.willPowerCost || this.investigator.isHidden) {
			return;
		}
		this.power[pwr] -= Game.willPowerCost;
		this.adeptsUsed++;
		if(Std.random(100) > this.getLowerWillChance()) {
			if(!this.isAI) {
				this.ui.messageWindow.show("You have failed to shatter the will of the investigator.");
				this.ui.status.update();
			}
			return;
		}
		this.investigator.lowerWillpower(1);
		if(!this.isAI) {
			this.ui.status.update();
		}
	}
	,killInvestigator: function() {
		this.investigator = null;
		this.hasInvestigator = false;
		this.investigatorTimeout = 3;
		this.game.failSectTasks();
		if(!this.isAI) {
			this.game.tutorial.play("investigatorDead");
		}
	}
	,convert: function(from,to) {
		if(this.power[from] < Game.powerConversionCost[from]) {
			return;
		}
		this.power[from] -= Game.powerConversionCost[from];
		this.power[to] += 1;
		if(!this.isAI) {
			this.ui.status.update();
		}
	}
	,canUpgrade: function(level) {
		if(level < 2) {
			if(this.getNumFollowers(level) >= Game.upgradeCost) {
				return this.get_virgins() >= level + 1;
			} else {
				return false;
			}
		} else {
			var tmp = this.get_priests();
			var _this = Static.rituals;
			if(tmp >= (__map_reserved["summoning"] != null ? _this.getReserved("summoning") : _this.h["summoning"]).priests && this.get_virgins() >= this.game.difficulty.numSummonVirgins) {
				return !this.isRitual;
			} else {
				return false;
			}
		}
	}
	,canStartRitual: function(id) {
		var _this = Static.rituals;
		var info = __map_reserved[id] != null ? _this.getReserved(id) : _this.h[id];
		if(this.isRitual || this.get_priests() < info.priests || this.get_virgins() < info.virgins) {
			return false;
		}
		if(id == "unveiling") {
			var _g = 0;
			var _g1 = this.game.cults;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				if(c.origin != null && !c.origin.isKnown[this.id]) {
					return true;
				}
			}
			return false;
		}
		return true;
	}
	,startRitual: function(id) {
		if(this.isRitual) {
			this.ui.alert("You must first finish the current ritual before starting another.");
			return;
		}
		var _this = Static.rituals;
		var info = __map_reserved[id] != null ? _this.getReserved(id) : _this.h[id];
		var _g = this;
		_g.set_virgins(_g.get_virgins() - info.virgins);
		this.ritual = info;
		this.ritualPoints = this.ritual.points;
		this.isRitual = true;
		this.ui.log2(this,this.get_fullName() + " has started the " + this.ritual.name + ".",{ symbol : "R"});
		if(!this.isAI) {
			this.ui.status.update();
		}
	}
	,upgrade: function(level) {
		if(!this.canUpgrade(level)) {
			return;
		}
		if(level == 2 && this.get_virgins() < this.game.difficulty.numSummonVirgins || level < 2 && this.get_virgins() < level + 1) {
			return;
		}
		if(level == 2) {
			this.summonStart();
			return;
		}
		var _g = this;
		_g.set_virgins(_g.get_virgins() - (level + 1));
		if(100 * Math.random() > this.getUpgradeChance(level)) {
			if(!this.isAI) {
				this.ui.messageWindow.show("Ritual failed.");
				this.ui.status.update();
			}
			return;
		}
		var _g1 = this;
		_g1.set_awareness(_g1.awareness + level);
		var ok = false;
		var upNode = null;
		if(this.origin != null && this.origin.level == level) {
			this.origin.upgrade();
			upNode = this.origin;
			ok = true;
		}
		if(!ok) {
			var upNode1 = this.findMostLinkedNode(level);
			if(upNode1 != null) {
				upNode1.upgrade();
				ok = true;
			}
		}
		if(!this.isAI) {
			this.ui.status.update();
		}
		if(this != this.game.player && this.get_priests() >= 2) {
			this.ui.log2(this,this.get_fullName() + " has " + this.get_priests() + " priests. Be careful.");
		}
		if(this.isParalyzed && this.get_priests() >= 1) {
			this.unParalyze();
			this.ui.log2(this,this.get_fullName() + " has gained a priest and is no longer paralyzed.");
		}
		this.ui.map.paint();
		if(!this.isAI) {
			if(this.get_adepts() >= 1) {
				this.game.tutorial.play("gainAdept");
			}
			if(this.get_adepts() >= 3) {
				this.game.tutorial.play("gain3Adepts");
			}
			if(this.get_priests() >= 1) {
				this.game.tutorial.play("gainPriest");
			}
		}
	}
	,findMostLinkedNode: function(level,noSects) {
		var node = null;
		var nlinks = -1;
		if(level != null) {
			var _g_head = this.nodes.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var n = val;
				if(noSects && n.sect != null) {
					continue;
				}
				var cnt = 0;
				var _g_head1 = n.links.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var l = val1;
					if(l.owner == this) {
						++cnt;
					}
				}
				if(n.level == level && cnt > nlinks) {
					node = n;
					nlinks = cnt;
				}
			}
		} else {
			var _g_head2 = this.nodes.h;
			while(_g_head2 != null) {
				var val2 = _g_head2.item;
				_g_head2 = _g_head2.next;
				var n1 = val2;
				if(noSects && n1.sect != null) {
					continue;
				}
				var cnt1 = 0;
				var _g_head3 = n1.links.h;
				while(_g_head3 != null) {
					var val3 = _g_head3.item;
					_g_head3 = _g_head3.next;
					var l1 = val3;
					if(l1.owner == this) {
						++cnt1;
					}
				}
				if(cnt1 > nlinks) {
					node = n1;
					nlinks = cnt1;
				}
			}
		}
		return node;
	}
	,unParalyze: function() {
		var node = this.findMostLinkedNode();
		node.makeGenerator();
		node.isTempGenerator = true;
		this.isParalyzed = false;
		this.paralyzedTurns = 0;
		this.origin = node;
	}
	,getInvestigatorChance: function() {
		var x = (20 * this.get_priests() + 5 * this.get_adepts() + 0.5 * this.get_neophytes()) * this.difficulty.investigatorChance * (100.0 + this.awareness) / 100.0;
		if(this.awareness <= 5) {
			x /= 2.0;
		}
		return x | 0;
	}
	,summonStart: function() {
		if(this.isRitual) {
			this.ui.alert("You must first finish the current ritual before starting another.");
			return;
		}
		var _g = this;
		_g.set_virgins(_g.get_virgins() - this.game.difficulty.numSummonVirgins);
		this.isRitual = true;
		var _g1 = 0;
		var _g11 = this.game.cults;
		while(_g1 < _g11.length) {
			var c = _g11[_g1];
			++_g1;
			this.isInfoKnown[c.id] = true;
		}
		var _this = Static.rituals;
		this.ritual = __map_reserved["summoning"] != null ? _this.getReserved("summoning") : _this.h["summoning"];
		this.ritualPoints = this.ritual.points;
		var _g2 = 0;
		var _g3 = this.game.cults;
		while(_g2 < _g3.length) {
			var p = _g3[_g2];
			++_g2;
			if(p != this && !p.isDead) {
				p.wars[this.id] = true;
				this.wars[p.id] = true;
			}
		}
		this.ui.alert(this.get_fullName() + " has started the " + this.ritual.name + ".<br><br>" + this.info.summonStart,{ w : 700, h : 400});
		this.ui.log2(this,this.get_fullName() + " has started the " + this.ritual.name + ".",{ symbol : "R"});
		if(!this.isAI) {
			this.ui.status.update();
		}
		if(this.isAI) {
			this.game.tutorial.play("enemyFinalRitual");
		}
	}
	,ritualFinish: function() {
		if(this.ritual.id == "summoning") {
			this.summonFinish();
		} else if(this.ritual.id == "unveiling") {
			this.ui.log2(this,this.get_fullName() + " has finished the " + this.ritual.name + ".",{ symbol : "R"});
			this.unveilingFinish();
		}
		this.isRitual = false;
	}
	,unveilingFinish: function() {
		if(!this.isAI) {
			this.ui.alert(this.get_fullName() + " has finished the " + this.ritual.name + ". All cult origins are revealed.",{ h : 130});
		}
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.origin != null) {
				c.origin.setVisible(this,true);
				c.origin.isKnown[this.id] = true;
			}
		}
		this.ui.map.paint();
	}
	,summonFinish: function() {
		if(100 * Math.random() > this.getUpgradeChance(2)) {
			var _g_head = this.nodes.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var n = val;
				if(n.level == 2) {
					n.level = 0;
					n.update();
					break;
				}
			}
			if(!this.isAI) {
				this.ui.alert("The stars were not properly aligned. The high priest goes insane.");
				var tmp = this.ui;
				var tmp1 = this.get_fullName() + " has failed to perform the ";
				var _this = Static.rituals;
				tmp.log2(this,tmp1 + (__map_reserved["summoning"] != null ? _this.getReserved("summoning") : _this.h["summoning"]).name + ".",{ symbol : "R"});
				this.ui.status.update();
			} else {
				var tmp2 = this.ui;
				var tmp3 = this.get_fullName() + " has failed to perform the ";
				var _this1 = Static.rituals;
				tmp2.alert(tmp3 + (__map_reserved["summoning"] != null ? _this1.getReserved("summoning") : _this1.h["summoning"]).name + ".<br><br>" + this.info.summonFail);
				var tmp4 = this.ui;
				var tmp5 = this.get_fullName() + " has failed the ";
				var _this2 = Static.rituals;
				tmp4.log2(this,tmp5 + (__map_reserved["summoning"] != null ? _this2.getReserved("summoning") : _this2.h["summoning"]).name + ".",{ symbol : "R"});
			}
			return;
		}
		this.ui.finish(this,"summon");
		var tmp6 = this.ui;
		var tmp7 = this.get_fullName() + " has completed the ";
		var _this3 = Static.rituals;
		tmp6.log2(this,tmp7 + (__map_reserved["summoning"] != null ? _this3.getReserved("summoning") : _this3.h["summoning"]).name + ". Game over.");
	}
	,turn: function() {
		if(this.isParalyzed && this.paralyzedTurns > 3) {
			this.unParalyze();
			var text = this.get_fullName() + " has gained an origin and is no longer paralyzed.";
			this.ui.log2(this,text);
			if(!this.isAI) {
				this.ui.alert(text,{ h : Std.parseInt(window.getComputedStyle(window.document.documentElement).getPropertyValue("--alert-window-height-2lines"))});
			}
		}
		if((this.get_priests() > 0 || this.get_adepts() > 0) && !this.hasInvestigator && 100 * Math.random() < this.getInvestigatorChance() && this.investigatorTimeout == 0) {
			this.hasInvestigator = true;
			this.ui.log2(this,"An investigator has found out about " + this.get_fullName() + ".",{ important : !this.isAI, symbol : "I"});
			this.investigator = new Investigator(this,this.ui,this.game);
			if(!this.isAI) {
				this.ui.status.update();
			}
			if(!this.isAI) {
				this.game.tutorial.play("investigator");
			}
		}
		if(this.investigatorTimeout > 0) {
			this.investigatorTimeout--;
		}
		if(this.isRitual) {
			this.ritualPoints -= this.get_priests();
			if(this.ritualPoints <= 0) {
				this.ritualFinish();
			}
			if(this.game.isFinished) {
				return;
			}
		}
		this.powerMod = [0,0,0,0];
		var _g_head = this.nodes.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var node = val;
			if(node.isGenerator) {
				var _g = 0;
				var _g1 = Game.numPowers;
				while(_g < _g1) {
					var i = _g++;
					if(100 * Math.random() < this.getResourceChance()) {
						this.power[i] += Math.round(node.powerGenerated[i]);
					}
					this.powerMod[i] += Math.round(node.powerGenerated[i]);
				}
			}
		}
		var value = Std.random(this.maxVirgins() + 1);
		var _g11 = this;
		_g11.set_virgins(_g11.get_virgins() + value);
		this.adeptsUsed = 0;
		if(this.hasInvestigator) {
			this.investigator.turn();
		}
		var _g1_head = this.sects.h;
		while(_g1_head != null) {
			var val1 = _g1_head.item;
			_g1_head = _g1_head.next;
			var s = val1;
			s.turn();
		}
		if(this.isParalyzed) {
			this.paralyzedTurns++;
		}
		this.createSects();
		if(this.options.getBool("sectAdvisor")) {
			this.game.sectAdvisor.run(this);
		}
	}
	,createSects: function() {
		if(this.isAI) {
			return;
		}
		while(this.sects.length < (this.nodes.length / 4 | 0)) {
			var node = this.findMostLinkedNode(null,true);
			this.createSect(node);
		}
	}
	,maxVirgins: function() {
		var x = this.get_neophytes() / 4 - 0.5 | 0;
		if(x < 0) {
			return 0;
		}
		return x;
	}
	,canActivate: function(node) {
		var _g = 0;
		var _g1 = Game.numPowers;
		while(_g < _g1) {
			var i = _g++;
			if(this.power[i] < node.power[i]) {
				return false;
			}
		}
		return true;
	}
	,activate: function(node) {
		if(this.isParalyzed) {
			if(!this.isAI) {
				this.ui.alert("Cult is paralyzed without the Origin.");
			}
			return "";
		}
		var ok = false;
		var _g_head = node.links.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var l = val;
			if(l.owner == this) {
				ok = true;
				break;
			}
		}
		if(!ok) {
			if(!this.isAI) {
				this.ui.alert("Must have an adjacent node to activate.");
			}
			return "";
		}
		if(node.owner == this) {
			return "isOwner";
		}
		if(node.isGenerator && node.owner != null) {
			var cnt = 0;
			var _g1_head = node.links.h;
			while(_g1_head != null) {
				var val1 = _g1_head.item;
				_g1_head = _g1_head.next;
				var n = val1;
				if(n.owner == node.owner) {
					++cnt;
				}
			}
			if(cnt >= 3) {
				if(!this.isAI) {
					this.ui.alert("Generator has " + cnt + " links.");
				}
				return "hasLinks";
			}
		}
		var _g1 = 0;
		var _g2 = Game.numPowers;
		while(_g1 < _g2) {
			var i = _g1++;
			if(this.power[i] < node.power[i]) {
				if(!this.isAI) {
					this.ui.alert("Not enough resources of needed type.");
				}
				return "notEnoughPower";
			}
		}
		var _g3 = 0;
		var _g4 = Game.numPowers;
		while(_g3 < _g4) {
			var i1 = _g3++;
			this.power[i1] -= node.power[i1];
		}
		if(100 * Math.random() > this.getGainChance(node)) {
			if(!this.isAI) {
				this.ui.messageWindow.show("Could not gain a follower.");
				this.ui.status.update();
			}
			return "failure";
		}
		if(node.level > 0) {
			node.level--;
		}
		if(node.sect != null) {
			node.owner.removeSect(node,"attack");
		}
		node.setOwner(this);
		if(node.isTempGenerator) {
			node.setGenerator(false);
			node.isTempGenerator = false;
		}
		this.checkVictory();
		var _g5 = 0;
		var _g6 = this.game.cults;
		while(_g5 < _g6.length) {
			var c = _g6[_g5];
			++_g5;
			if(c != this && node.visibility[c.id]) {
				c.highlightNode(node);
			}
		}
		return "ok";
	}
	,declareWar: function(cult) {
		if(cult.wars[this.id]) {
			return;
		}
		cult.wars[this.id] = true;
		this.wars[cult.id] = true;
		var text = this.get_fullName() + " has started a war against " + cult.get_fullName() + ".";
		var m = { id : -1, old : false, type : "cults", text : text, obj : { c1 : this, c2 : cult}, turn : this.game.turns + 1, params : { }};
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(this.isInfoKnown[c.id] || cult.isInfoKnown[c.id] || this.isDiscovered[c.id] || cult.isDiscovered[c.id]) {
				c.log(text);
				c.logPanel(m);
			}
		}
		if(!cult.isAI) {
			this.ui.alert(text,{ h : Std.parseInt(window.getComputedStyle(window.document.documentElement).getPropertyValue("--alert-window-height-2lines"))});
		}
	}
	,makePeace: function(cult) {
		if(!cult.wars[this.id]) {
			return;
		}
		cult.wars[this.id] = false;
		this.wars[cult.id] = false;
		var text = this.get_fullName() + " has made peace with " + cult.get_fullName() + ".";
		var m = { id : -1, old : false, type : "cults", text : text, obj : { c1 : this, c2 : cult}, turn : this.game.turns + 1, params : { }};
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(this.isInfoKnown[c.id] || cult.isInfoKnown[c.id] || this.isDiscovered[c.id] || cult.isDiscovered[c.id]) {
				c.log(text);
				c.logPanel(m);
			}
		}
	}
	,loseNode: function(node,cult) {
		var _g = this;
		_g.set_awareness(_g.awareness + 1);
		if(!this.isAI) {
			this.ui.status.update();
		}
		if(cult != null && this.nodes.length > 0) {
			cult.declareWar(this);
		}
		if(this.origin == node) {
			this.loseOrigin(cult);
		}
		node.update();
		this.checkDeath();
	}
	,loseOrigin: function(cult) {
		if(this.nodes.length > 0) {
			this.ui.log2(this,this.get_fullName() + " has lost its Origin.");
		}
		if(this.isRitual) {
			this.isRitual = false;
			this.ui.log2(this,"The execution of " + this.ritual.name + " has been stopped.",{ symbol : "X"});
			this.game.failSectTasks();
		}
		var ok = false;
		this.origin = null;
		var _g_head = this.nodes.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var n = val;
			if(n.level == 2) {
				this.origin = n;
				ok = true;
				break;
			}
		}
		if(!ok) {
			if(this.nodes.length > 0) {
				this.ui.log2(this,"Destroying the origin of " + this.get_fullName() + " has left it completely paralyzed.",{ symbol : "X"});
			}
			this.isParalyzed = true;
			if(this.hasInvestigator) {
				this.killInvestigator();
				if(this.nodes.length > 0) {
					this.ui.log2(this,"The investigator of the " + this.get_fullName() + " has disappeared thinking the cult is finished.",{ symbol : "I"});
				}
			}
			if(!this.isAI) {
				this.game.tutorial.play("cultParalyzed");
			}
		} else {
			this.ui.log2(this,"Another priest becomes the Origin of " + this.get_fullName() + ".");
			this.origin.update();
			this.ui.map.paint();
		}
		if(cult != null) {
			cult.gainStash(this);
		}
	}
	,gainStash: function(from) {
		if(Std.random(100) > 30) {
			return;
		}
		var text = this.get_fullName() + " has acquired a stash of resources with the origin of " + from.get_fullName();
		text += this.isAI ? "." : ": ";
		var sum = 0;
		sum += this.getNumFollowers(0);
		sum += 2 * this.getNumFollowers(1);
		sum += 3 * this.getNumFollowers(2);
		var val = sum / 4 | 0;
		if(val == 0) {
			return;
		}
		var id = Std.random(3);
		if(Std.random(100) < 25) {
			id = 3;
		}
		if(!this.isAI) {
			text += val + " " + UI.powerName(id) + ".";
		}
		this.power[id] += val;
		this.ui.log2(from,text);
		if(!this.isAI) {
			this.ui.alert(text,{ h : Std.parseInt(window.getComputedStyle(window.document.documentElement).getPropertyValue("--alert-window-height-2lines"))});
			this.ui.status.update();
		}
	}
	,checkVictory: function() {
		if(this.isDead || this.isParalyzed) {
			return;
		}
		var ok = true;
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			if(p != this && !p.isDead && !p.isParalyzed) {
				ok = false;
			}
		}
		if(!ok) {
			return;
		}
		this.ui.finish(this,"conquer");
	}
	,checkDeath: function() {
		if(this.nodes.length > 0 || this.isDead) {
			return;
		}
		this.ui.log2(this,this.get_fullName() + " has been destroyed, forgotten by time.",{ symbol : "X"});
		this.ui.map.paint();
		this.isDead = true;
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.wars[this.id] = false;
		}
		var _g2 = 0;
		var _g3 = this.wars.length;
		while(_g2 < _g3) {
			var i = _g2++;
			this.wars[i] = false;
		}
		this.hasInvestigator = false;
		this.investigator = null;
		var _g4 = 0;
		var _g5 = this.game.cults;
		while(_g4 < _g5.length) {
			var c1 = _g5[_g4];
			++_g4;
			var _g4_head = c1.sects.h;
			while(_g4_head != null) {
				var val = _g4_head.item;
				_g4_head = _g4_head.next;
				var s = val;
				if(s.task != null && s.task.type == "cult" && s.taskTarget == this) {
					s.clearTask();
				}
			}
		}
		if(!this.isAI) {
			var humansAlive = false;
			var _g6 = 0;
			var _g7 = this.game.cults;
			while(_g6 < _g7.length) {
				var c2 = _g7[_g6];
				++_g6;
				if(!c2.isAI && !c2.isDead) {
					humansAlive = true;
					break;
				}
			}
			if(!humansAlive) {
				this.ui.finish(this,this.game.difficulty.numPlayers == 1 ? "wiped" : "multiplayerFinish");
			}
		} else {
			this.checkVictory();
		}
	}
	,discover: function(cult) {
		cult.isDiscovered[this.id] = true;
		this.isDiscovered[cult.id] = true;
		this.ui.log2(this,this.get_fullName() + " has discovered the existence of " + cult.get_fullName() + ".");
		if(!this.isAI) {
			if(this.sects.length > 0) {
				this.game.tutorial.play("discoverCult");
				this.game.tutorial.disable("discoverCultNoSects");
			} else {
				this.game.tutorial.play("discoverCultNoSects");
				this.game.tutorial.disable("discoverCult");
			}
		}
	}
	,log: function(s) {
		if(this.isAI) {
			return;
		}
		var s2 = this.ui.logWindow.getRenderedMessage(s);
		this.logMessages += s2;
	}
	,logPanelShort: function(s,params) {
		this.logPanel({ id : -1, old : false, type : "cult", text : s, obj : this, turn : this.game.turns + 1, params : params == null ? { } : params});
	}
	,logPanel: function(m) {
		if(this.logPanelMessages.length >= 24) {
			this.logPanelMessages.clear();
		}
		this.logPanelMessages.add(m);
		this.ui.logPanel.paint();
	}
	,highlightNode: function(n) {
		if(this.isAI) {
			return;
		}
		this.highlightedNodes.add(n);
	}
	,get_virgins: function() {
		return this.power[3];
	}
	,set_virgins: function(v) {
		this.power[3] = v;
		return v;
	}
	,getNumFollowers: function(level) {
		var cnt = 0;
		var _g_head = this.nodes.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var n = val;
			if(n.level == level) {
				++cnt;
			}
		}
		return cnt;
	}
	,get_neophytes: function() {
		return this.getNumFollowers(0);
	}
	,get_adepts: function() {
		return this.getNumFollowers(1);
	}
	,get_priests: function() {
		return this.getNumFollowers(2);
	}
	,get_fullName: function() {
		return UI.cultName(this.id,this.info);
	}
};
var AI = function(gvar,uivar,id,infoID) {
	Cult.call(this,gvar,uivar,id,infoID);
	this.isAI = true;
	if(this.game.difficultyLevel == 0) {
		this.difficulty = Static.difficulty[2];
	} else if(this.game.difficultyLevel == 2) {
		this.difficulty = Static.difficulty[0];
	} else {
		this.difficulty = Static.difficulty[1];
	}
};
AI.__name__ = true;
AI.__super__ = Cult;
AI.prototype = $extend(Cult.prototype,{
	aiTurn: function() {
		if(this.isParalyzed && this.hasInvestigator) {
			this.aiLowerAwarenessHard();
			this.aiLowerWillpower();
			return;
		}
		if(this.isParalyzed) {
			this.aiLowerWillpower();
			this.aiUpgradeFollowers();
			return;
		}
		if(this.hasInvestigator && this.get_adepts() > 0) {
			if(this.awareness >= this.difficulty.maxAwareness) {
				this.aiLowerAwarenessHard();
			} else {
				this.aiLowerWillpower();
			}
			return;
		}
		this.aiUpgradeFollowers();
		if(this.isRitual && this.ritual.id == "summoning") {
			this.aiLowerAwarenessHard();
		}
		this.aiLowerAwareness();
		this.aiSummon();
		if(this.awareness > this.difficulty.maxAwareness && this.get_adepts() > 0) {
			return;
		}
		var list = [];
		var _g = 0;
		var _g1 = this.game.nodes;
		while(_g < _g1.length) {
			var node = _g1[_g];
			++_g;
			if(node.owner == this || !node.visibility[this.id] || node.owner != null && node.owner.isDebugInvisible) {
				continue;
			}
			var item = { node : node, priority : 0};
			if(node.owner != null && node.level == 2 && node.owner.isRitual && node.owner.ritual.id == "summoning") {
				item.priority += 3;
			}
			if(node.owner == null) {
				item.priority++;
			}
			if(node.owner != null && this.wars[node.owner.id]) {
				item.priority++;
			} else if(node.owner != null && node.owner.isRitual && node.owner.ritual.id == "summoning") {
				item.priority += 2;
			} else if(node.owner != null) {
				item.priority--;
			}
			if(node.owner != null && this.hasInvestigator) {
				item.priority--;
			}
			if(node.isGenerator && !node.isProtected) {
				item.priority += 2;
			}
			if(this.canActivate(node)) {
				item.priority++;
			}
			list.push(item);
		}
		list.sort(function(x,y) {
			if(x.priority == y.priority) {
				return 0;
			} else if(x.priority > y.priority) {
				return -1;
			} else {
				return 1;
			}
		});
		var _g2 = 0;
		while(_g2 < list.length) {
			var item1 = list[_g2];
			++_g2;
			var node1 = item1.node;
			var ret = this.activate(node1);
			if(ret == "ok") {
				continue;
			}
			if(ret == "notEnoughPower") {
				this.aiActivateNodeByConvert(node1);
			} else {
				var tmp = ret == "hasLinks";
			}
		}
		this.aiTryPeace();
	}
	,aiTryPeace: function() {
		if(this.isRitual) {
			return;
		}
		var ok = false;
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.isRitual) {
				ok = true;
				break;
			}
		}
		if(!ok) {
			return;
		}
		var _g2 = 0;
		while(_g2 < 3) {
			var i = _g2++;
			if(this.wars[i] && !this.game.cults[i].isRitual) {
				if(Math.random() * 100 > 30) {
					continue;
				}
				this.makePeace(this.game.cults[i]);
			}
		}
	}
	,aiUpgradeFollowers: function() {
		if(this.get_virgins() == 0) {
			return;
		}
		if(this.get_adepts() < 5 && this.getUpgradeChance(0) > 70 && this.get_virgins() > 0) {
			while(!(!this.canUpgrade(0) || this.get_virgins() < 1 || this.get_adepts() >= 5)) {
				this.upgrade(0);
				if(Game.debugAI) {
					console.log("AI.hx:216:",this.name + " upgrade neophyte, adepts: " + this.get_adepts());
				}
			}
			return;
		}
		if(this.get_priests() < 3 && this.getUpgradeChance(1) > 60 && this.get_virgins() > 1) {
			while(!(!this.canUpgrade(1) || this.get_virgins() < 2 || this.get_priests() >= 3)) {
				this.upgrade(1);
				if(Game.debugAI) {
					console.log("AI.hx:232:","!!! " + this.name + " upgrade adept, priests: " + this.get_priests());
				}
			}
			return;
		}
	}
	,aiLowerWillpower: function() {
		if(!this.hasInvestigator || this.investigator.isHidden || this.get_adepts() == 0) {
			return;
		}
		var _g = 0;
		var _g1 = Game.numPowers;
		while(_g < _g1) {
			var i = _g++;
			this.lowerWillpower(i);
			this.lowerWillpower(i);
		}
	}
	,aiLowerAwarenessHard: function() {
		if(this.awareness == 0 || this.get_adepts() == 0) {
			return;
		}
		var prevAwareness = this.awareness;
		while(this.get_virgins() > 0 && this.adeptsUsed < this.get_adepts() && this.awareness >= 0) {
			this.convert(3,0);
			this.lowerAwareness(0);
		}
		if(Game.debugAI && this.awareness != prevAwareness) {
			console.log("AI.hx:272:",this.name + " virgin awareness " + prevAwareness + "% -> " + this.awareness + "%");
		}
	}
	,aiLowerAwareness: function() {
		if(this.awareness < this.difficulty.maxAwareness && !this.hasInvestigator || this.awareness < 5 && this.hasInvestigator || this.get_adepts() == 0 || this.adeptsUsed >= this.get_adepts()) {
			return;
		}
		var prevAwareness = this.awareness;
		var _g = 0;
		var _g1 = Game.numPowers;
		while(_g < _g1) {
			var i = _g++;
			while(this.power[i] > 0 && this.adeptsUsed < this.get_adepts() && this.awareness >= this.difficulty.maxAwareness) this.lowerAwareness(i);
		}
		if(Game.debugAI && this.awareness != prevAwareness) {
			console.log("AI.hx:293:",this.name + " awareness " + prevAwareness + "% -> " + this.awareness + "%");
		}
	}
	,aiSummon: function() {
		if(this.get_priests() < 3 || this.get_virgins() < 9 || this.getUpgradeChance(2) < 50 || this.isRitual) {
			return;
		}
		if(Game.debugAI) {
			console.log("AI.hx:304:",this.name + " TRY SUMMON!");
		}
		this.summonStart();
	}
	,aiActivateNodeByConvert: function(node) {
		var resNeed = -1;
		var _g = 0;
		var _g1 = Game.numPowers;
		while(_g < _g1) {
			var i = _g++;
			if(this.power[i] < node.power[i]) {
				resNeed = i;
			}
		}
		var resConv = -1;
		var _g2 = 0;
		var _g3 = Game.numPowers;
		while(_g2 < _g3) {
			var i1 = _g2++;
			if(i1 != resNeed) {
				if((this.power[i1] / Game.powerConversionCost[i1] | 0) > node.power[resNeed]) {
					resConv = i1;
				}
			}
		}
		if(resConv < 0) {
			return;
		}
		var _g4 = 0;
		var _g5 = node.power[resNeed];
		while(_g4 < _g5) {
			var i2 = _g4++;
			this.convert(resConv,resNeed);
		}
		this.activate(node);
	}
});
var Alert = function(uivar,gvar) {
	this.ui = uivar;
	this.game = gvar;
	this.isYesNo = false;
	this.isVisible = false;
	this.queue = new haxe_ds_List();
	this.yesFunc = null;
};
Alert.__name__ = true;
Alert.prototype = {
	onClose: function(event) {
		this.border.style.display = "none";
		this.bg.style.display = "none";
		window.document.body.removeChild(this.border);
		window.document.body.removeChild(this.bg);
		this.isVisible = false;
		if(this.queue.length > 0) {
			var x = this.queue.pop();
			this.show(x.msg,x.opts);
		}
	}
	,onYes: function(event) {
		if(this.yesFunc != null) {
			this.yesFunc();
		}
		this.onClose(event);
	}
	,show: function(s,opts) {
		if(this.isVisible) {
			this.queue.add({ msg : s, opts : opts});
			return;
		}
		if(opts == null) {
			opts = { w : 600, h : 250, shadow : true, shadowOpacity : 0.8, center : true};
		}
		if(opts.yesNo) {
			this.isYesNo = true;
		} else {
			this.isYesNo = false;
		}
		if(opts.w == null) {
			opts.w = 600;
		}
		if(opts.h == null) {
			opts.h = 250;
		}
		if(s.length < 46) {
			opts.h = Std.parseInt(window.getComputedStyle(window.document.documentElement).getPropertyValue("--alert-window-min-height"));
		}
		if(opts.shadow == null) {
			opts.shadow = true;
		}
		if(opts.shadowOpacity == null) {
			opts.shadowOpacity = 0.8;
		}
		if(opts.center == null) {
			opts.center = true;
		}
		this.window = Tools.window({ id : "alert", shadowLayer : 24, fontSize : opts.fontSize, bold : true, w : opts.w, h : opts.h, z : 25});
		this.border = window.document.getElementById("alertBorder");
		this.bg = window.document.getElementById("alertBG");
		this.text = window.document.createElement("div");
		this.text.className = "uiText";
		this.window.appendChild(this.text);
		if(opts.yesNo != null) {
			var container = this.window;
			var w = Std.parseInt(container.style.width);
			var b = Tools.button({ id : null, text : "Close", w : 80, h : null, x : null, y : null, container : container});
			b.style.left = "50%";
			b.style.bottom = "var(--close-button-bottom)";
			b.style.transform = "translate(-50%)";
			var yes = b;
			yes.innerHTML = "Yes";
			yes.style.left = "33%";
			yes.onclick = $bind(this,this.onYes);
			this.yesFunc = opts.onYes;
			var container1 = this.window;
			var w1 = Std.parseInt(container1.style.width);
			var b1 = Tools.button({ id : null, text : "Close", w : 80, h : null, x : null, y : null, container : container1});
			b1.style.left = "50%";
			b1.style.bottom = "var(--close-button-bottom)";
			b1.style.transform = "translate(-50%)";
			var no = b1;
			no.innerHTML = "No";
			no.style.left = "66%";
			no.onclick = $bind(this,this.onClose);
		} else {
			var container2 = this.window;
			var w2 = Std.parseInt(container2.style.width);
			var b2 = Tools.button({ id : null, text : "Close", w : 80, h : null, x : null, y : null, container : container2});
			b2.style.left = "50%";
			b2.style.bottom = "var(--close-button-bottom)";
			b2.style.transform = "translate(-50%)";
			var close = b2;
			close.onclick = $bind(this,this.onClose);
			if(this.queue.length > 0) {
				close.innerHTML = "Next";
			}
		}
		if(opts.center) {
			this.text.innerHTML = "<center>" + s + "</center>";
		} else {
			this.text.innerHTML = s;
		}
		this.border.style.display = "inline";
		this.bg.style.display = "inline";
		this.isVisible = true;
	}
};
var Config = function() {
};
Config.__name__ = true;
Config.prototype = {
	get: function(name) {
		return getCookie(name);
	}
	,getInt: function(name) {
		var str = getCookie(name);
		if(str == null) {
			return 0;
		}
		return Std.parseInt(str);
	}
	,getBool: function(name) {
		var str = getCookie(name);
		if(str == null) {
			return false;
		}
		return str == "true";
	}
	,set: function(name,val) {
		return setCookie(name,val,new Date(2015, 0, 0, 0, 0, 0, 0));
	}
};
var Window = function(uivar,gvar,name,w,h,z,closeY) {
	this.ui = uivar;
	this.game = gvar;
	this.isVisible = false;
	this.window = Tools.window({ id : name, w : w, h : h, z : z});
	this.border = window.document.getElementById(name + "Border");
	this.bg = window.document.getElementById(name + "BG");
	var container = this.window;
	var w1 = Std.parseInt(container.style.width);
	var b = Tools.button({ id : null, text : "Close", w : 80, h : null, x : null, y : null, container : container});
	b.style.left = "50%";
	b.style.bottom = "var(--close-button-bottom)";
	b.style.transform = "translate(-50%)";
	this.close = b;
	this.close.onclick = $bind(this,this.onClose);
};
Window.__name__ = true;
Window.prototype = {
	show: function() {
		this.border.style.display = "inline";
		this.bg.style.display = "inline";
		this.close.style.visibility = "visible";
		this.isVisible = true;
		this.onShow();
	}
	,onShow: function() {
	}
	,onKey: function(e) {
	}
	,onClose: function(event) {
		this.border.style.display = "none";
		this.bg.style.display = "none";
		this.isVisible = false;
		this.onCloseHook();
	}
	,onCloseHook: function() {
	}
};
var CustomMenu = function(uivar,gvar) {
	Window.call(this,uivar,gvar,"customMenu",1000,536,20,493);
	Tools.label({ id : "titleLabel", text : "Custom game parameters", w : 300, h : 30, x : 320, y : 5, container : this.window});
	var divel = window.document.createElement("div");
	divel.className = "uiText";
	divel.style.top = "4.5%";
	divel.style.height = "81%";
	this.window.appendChild(divel);
	this.difElements = new haxe_ds_List();
	var y = 10;
	var _g = 0;
	var _g1 = CustomMenu.difElementInfo;
	while(_g < _g1.length) {
		var info = _g1[_g];
		++_g;
		Tools.label({ id : "label" + info.name, text : info.title, w : 300, h : 20, x : 10, y : y, fontSize : 14, container : divel});
		var el = null;
		if(info.type == "bool") {
			el = Tools.checkbox({ id : info.name, text : "" + Std.string(Reflect.field(Static.difficulty[2],info.name)), w : 70, h : null, x : 320, y : y, fontSize : 14, container : divel});
		} else {
			el = Tools.textfield({ id : info.name, text : "" + Std.string(Reflect.field(Static.difficulty[2],info.name)), w : 70, h : 20, x : 320, y : y, fontSize : 14, container : divel});
		}
		Tools.label({ id : "note" + info.name, text : info.note, w : 540, h : 20, x : 410, y : y, fontSize : 14, bold : false, container : divel});
		y += 30;
		this.difElements.add(el);
	}
	var b = Tools.button({ id : "startCustomGame", text : "Start", w : 80, h : null, x : null, y : null, container : this.window, func : $bind(this,this.onStartGame)});
	b.style.left = "33%";
	b.style.bottom = "3%";
	b.style.transform = "translate(-50%)";
	this.close.style.left = "66%";
	this.close.style.bottom = "3%";
	this.close.style.transform = "translate(-50%)";
};
CustomMenu.__name__ = true;
CustomMenu.__super__ = Window;
CustomMenu.prototype = $extend(Window.prototype,{
	onStartGame: function(e) {
		var dif = { level : -1};
		var _g = 0;
		var _g1 = CustomMenu.difElementInfo;
		while(_g < _g1.length) {
			var info = _g1[_g];
			++_g;
			var el = null;
			var _g_head = this.difElements.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var e1 = val;
				if(e1.id == info.name) {
					el = e1;
					break;
				}
			}
			var value = null;
			if(info.type == "int") {
				value = Std.parseInt(el.value);
			} else if(info.type == "float") {
				value = parseFloat(el.value);
			} else if(info.type == "bool") {
				value = el.checked;
			}
			dif[info.name] = value;
		}
		if(dif.numPlayers < 1) {
			dif.numPlayers = 1;
		}
		if(dif.numCults < 2) {
			dif.numCults = 2;
		}
		if(dif.numPlayers > 8) {
			dif.numPlayers = 8;
		}
		if(dif.numCults > 8) {
			dif.numCults = 8;
		}
		this.game.restart(-1,dif);
		this.onClose(null);
		this.ui.mainMenu.onClose(null);
	}
	,onKey: function(e) {
		if(e.keyCode == 27) {
			this.onClose(null);
		}
	}
	,onCloseHook: function() {
		this.ui.mainMenu.show();
	}
});
var DateTools = function() { };
DateTools.__name__ = true;
DateTools.__format_get = function(d,e) {
	switch(e) {
	case "%":
		return "%";
	case "A":
		return DateTools.DAY_NAMES[d.getDay()];
	case "B":
		return DateTools.MONTH_NAMES[d.getMonth()];
	case "C":
		return StringTools.lpad(Std.string(d.getFullYear() / 100 | 0),"0",2);
	case "D":
		return DateTools.__format(d,"%m/%d/%y");
	case "F":
		return DateTools.__format(d,"%Y-%m-%d");
	case "I":case "l":
		var hour = d.getHours() % 12;
		return StringTools.lpad(Std.string(hour == 0 ? 12 : hour),e == "I" ? "0" : " ",2);
	case "M":
		return StringTools.lpad(Std.string(d.getMinutes()),"0",2);
	case "R":
		return DateTools.__format(d,"%H:%M");
	case "S":
		return StringTools.lpad(Std.string(d.getSeconds()),"0",2);
	case "T":
		return DateTools.__format(d,"%H:%M:%S");
	case "Y":
		return Std.string(d.getFullYear());
	case "a":
		return DateTools.DAY_SHORT_NAMES[d.getDay()];
	case "b":case "h":
		return DateTools.MONTH_SHORT_NAMES[d.getMonth()];
	case "d":
		return StringTools.lpad(Std.string(d.getDate()),"0",2);
	case "e":
		return Std.string(d.getDate());
	case "H":case "k":
		return StringTools.lpad(Std.string(d.getHours()),e == "H" ? "0" : " ",2);
	case "m":
		return StringTools.lpad(Std.string(d.getMonth() + 1),"0",2);
	case "n":
		return "\n";
	case "p":
		if(d.getHours() > 11) {
			return "PM";
		} else {
			return "AM";
		}
		break;
	case "r":
		return DateTools.__format(d,"%I:%M:%S %p");
	case "s":
		return Std.string(d.getTime() / 1000 | 0);
	case "t":
		return "\t";
	case "u":
		var t = d.getDay();
		if(t == 0) {
			return "7";
		} else if(t == null) {
			return "null";
		} else {
			return "" + t;
		}
		break;
	case "w":
		return Std.string(d.getDay());
	case "y":
		return StringTools.lpad(Std.string(d.getFullYear() % 100),"0",2);
	default:
		throw new js__$Boot_HaxeError("Date.format %" + e + "- not implemented yet.");
	}
};
DateTools.__format = function(d,f) {
	var r_b = "";
	var p = 0;
	while(true) {
		var np = f.indexOf("%",p);
		if(np < 0) {
			break;
		}
		var len = np - p;
		r_b += len == null ? HxOverrides.substr(f,p,null) : HxOverrides.substr(f,p,len);
		r_b += Std.string(DateTools.__format_get(d,HxOverrides.substr(f,np + 1,1)));
		p = np + 2;
	}
	var len1 = f.length - p;
	r_b += len1 == null ? HxOverrides.substr(f,p,null) : HxOverrides.substr(f,p,len1);
	return r_b;
};
DateTools.format = function(d,f) {
	return DateTools.__format(d,f);
};
var Debug = function(uivar,gvar) {
	Window.call(this,uivar,gvar,"debug",800,536,20,493);
	this.buttons = [];
	this.menu = window.document.createElement("div");
	this.menu.className = "uiText";
	this.window.appendChild(this.menu);
	this.lastMenuY = -20;
	this.menuItem = 0;
	this.addItem(0,"Give power",$bind(this,this.onGivePower));
	this.addItem(0,"Open map",$bind(this,this.onOpenMap));
	this.addItem(0,"Investigator: AI",$bind(this,this.onInvestigatorAI));
	this.addItem(0,"Investigator: Player",$bind(this,this.onInvestigatorPlayer));
	this.addItem(0,"Victory: Summon",$bind(this,this.onVictorySummon));
	this.addItem(0,"AI Victory: Summon",$bind(this,this.onVictorySummonAI));
	this.addItem(0,"Total war",$bind(this,this.onTotalWar));
	this.addItem(0,"Invisibility toggle",$bind(this,this.onToggleInvisible));
	this.addItem(0,"Trace timing toggle",$bind(this,this.onTiming));
	this.addItem(0,"Trace AI toggle",$bind(this,this.onAI));
	this.addItem(0,"Node vis toggle",$bind(this,this.onVis));
	this.addItem(0,"Node near toggle",$bind(this,this.onNear));
	this.addItem(0,"Give adepts",$bind(this,this.onGiveAdepts));
	this.addItem(0,"Upgrade sects",$bind(this,this.onUpgradeSects));
	this.lastMenuY = -20;
	this.addItem(1,"Trace Director toggle",$bind(this,this.onDirector));
};
Debug.__name__ = true;
Debug.__super__ = Window;
Debug.prototype = $extend(Window.prototype,{
	onUpgradeSects: function(event) {
		var _g_head = this.game.player.sects.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var s = val;
			s.size += 100;
		}
	}
	,onGiveAdepts: function(event) {
		this.onGivePower(null);
		var _g_head = this.game.player.nodes.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var n = val;
			if(n.level < 1 && Math.random() < 0.5) {
				n.upgrade();
			}
			var _g_head1 = n.links.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var n2 = val1;
				if(Math.random() < 0.2) {
					this.game.player.activate(n2);
				}
			}
		}
		var _g_head2 = this.game.player.nodes.h;
		while(_g_head2 != null) {
			var val2 = _g_head2.item;
			_g_head2 = _g_head2.next;
			var n1 = val2;
			if(n1.level < 1 && Math.random() < 0.5) {
				n1.upgrade();
			}
			var _g_head3 = n1.links.h;
			while(_g_head3 != null) {
				var val3 = _g_head3.item;
				_g_head3 = _g_head3.next;
				var n21 = val3;
				if(Math.random() < 0.2) {
					this.game.player.activate(n21);
				}
			}
		}
		var _g_head4 = this.game.player.nodes.h;
		while(_g_head4 != null) {
			var val4 = _g_head4.item;
			_g_head4 = _g_head4.next;
			var n3 = val4;
			if(n3.level < 1 && Math.random() < 0.5) {
				n3.upgrade();
			}
			var _g_head5 = n3.links.h;
			while(_g_head5 != null) {
				var val5 = _g_head5.item;
				_g_head5 = _g_head5.next;
				var n22 = val5;
				if(Math.random() < 0.2) {
					this.game.player.activate(n22);
				}
			}
		}
		this.game.player.set_awareness(0);
	}
	,onTiming: function(event) {
		Game.debugTime = !Game.debugTime;
		console.log("./jui/Debug.hx:72:","timing " + (Game.debugTime ? "on" : "off"));
	}
	,onAI: function(event) {
		Game.debugAI = !Game.debugAI;
		console.log("./jui/Debug.hx:80:","trace ai " + (Game.debugAI ? "on" : "off"));
	}
	,onDirector: function(event) {
		Game.debugDirector = !Game.debugDirector;
		console.log("./jui/Debug.hx:88:","trace director " + (Game.debugDirector ? "on" : "off"));
	}
	,onVis: function(event) {
		Game.debugVis = !Game.debugVis;
		var _g = 0;
		var _g1 = this.game.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			n.update();
		}
		console.log("./jui/Debug.hx:98:","node visibility to cults info " + (Game.debugVis ? "on" : "off"));
	}
	,onNear: function(event) {
		Game.debugNear = !Game.debugNear;
		var _g = 0;
		var _g1 = this.game.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			n.update();
		}
		console.log("./jui/Debug.hx:108:","node nearness info " + (Game.debugNear ? "on" : "off"));
	}
	,onToggleInvisible: function(event) {
		this.game.player.isDebugInvisible = !this.game.player.isDebugInvisible;
		console.log("./jui/Debug.hx:116:","invisibility " + (this.game.player.isDebugInvisible ? "on" : "off"));
	}
	,onTotalWar: function(event) {
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			if(0 != p.id) {
				p.wars[0] = true;
			}
			if(1 != p.id) {
				p.wars[1] = true;
			}
			if(2 != p.id) {
				p.wars[2] = true;
			}
			if(3 != p.id) {
				p.wars[3] = true;
			}
		}
	}
	,onVictorySummon: function(event) {
		this.ui.finish(this.game.cults[0],"summon");
	}
	,onVictorySummonAI: function(event) {
		this.ui.finish(this.game.cults[1],"summon");
	}
	,onInvestigatorAI: function(event) {
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.isAI) {
				c.hasInvestigator = true;
				c.investigator = new Investigator(c,this.ui,this.game);
			}
		}
	}
	,onInvestigatorPlayer: function(event) {
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c == this.game.player) {
				c.hasInvestigator = true;
				c.investigator = new Investigator(c,this.ui,this.game);
			}
		}
	}
	,onGivePower: function(event) {
		this.game.player.power[0] += 100;
		this.game.player.power[1] += 100;
		this.game.player.power[2] += 100;
		this.game.player.power[3] += 100;
		this.ui.status.update();
	}
	,onOpenMap: function(event) {
		var _g = 0;
		var _g1 = this.game.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			n.setVisible(this.game.player,true);
			n.isKnown[this.game.player.id] = true;
		}
		var _g2 = 0;
		var _g3 = this.game.cults;
		while(_g2 < _g3.length) {
			var c = _g3[_g2];
			++_g2;
			c.isInfoKnown[this.game.player.id] = true;
			var _g2_head = c.nodes.h;
			while(_g2_head != null) {
				var val = _g2_head.item;
				_g2_head = _g2_head.next;
				var n1 = val;
				n1.update();
			}
		}
		this.ui.map.paint();
	}
	,addItem: function(row,title,func) {
		var _gthis = this;
		this.lastMenuY += 30;
		var sym = this.menuItem + 49;
		if(this.menuItem > 8) {
			sym = this.menuItem - 9 + 65 + 32;
		}
		var b = Tools.button({ id : "menuItem" + this.lastMenuY, fontSize : 12, bold : false, text : String.fromCodePoint(sym) + " " + title, w : 200, h : 22, x : 10 + row * 210, y : this.lastMenuY, container : this.menu, func : function(event) {
			func(event);
			_gthis.ui.map.paint();
		}});
		b.name = String.fromCodePoint(sym);
		this.buttons.push(b);
		this.menuItem++;
	}
	,onKey: function(e) {
		if(e.keyCode == 27 || e.keyCode == 13 || e.keyCode == 32) {
			this.onClose(null);
			return;
		}
		var _g = 0;
		var _g1 = this.buttons;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			var code = e.keyCode;
			if(b.name == String.fromCodePoint(code).toLowerCase()) {
				b.onclick(null);
				break;
			}
		}
	}
});
var Director = function(g,vui) {
	this.game = g;
	this.ui = vui;
};
Director.__name__ = true;
Director.prototype = {
	turn: function() {
		if(this.game.turns < 5) {
			return;
		}
		var cult = this.findWeakestCult();
		this.giveVirgins(cult);
		this.doubleGenerators(cult);
	}
	,giveVirgins: function(cult) {
		if(Math.random() > 0.3) {
			return;
		}
		if(cult.maxVirgins() < 1) {
			return;
		}
		var n = 1 + (Math.random() * 2 | 0);
		var _g = cult;
		_g.set_virgins(_g.get_virgins() + 2);
		if(Game.debugDirector) {
			console.log("Director.hx:121:","give " + n + " virgins to " + cult.name);
		}
	}
	,doubleGenerators: function(cult) {
		if(Math.random() > 0.3) {
			return;
		}
		var power = [0,0,0];
		var _g_head = cult.nodes.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var node = val;
			if(!node.isGenerator) {
				continue;
			}
			var _g = 0;
			var _g1 = Game.numPowers;
			while(_g < _g1) {
				var i = _g++;
				if(node.powerGenerated[i] > 0) {
					power[i] += node.powerGenerated[i];
					if(Math.random() < 0.1) {
						power[i] += node.powerGenerated[i];
					}
				}
			}
		}
		var _g11 = 0;
		var _g2 = Game.numPowers;
		while(_g11 < _g2) {
			var i1 = _g11++;
			cult.power[i1] += power[i1];
		}
		if(Game.debugDirector) {
			console.log("Director.hx:121:","give " + Std.string(power) + " to " + cult.name);
		}
	}
	,getCultPower: function(cult) {
		var power = 0;
		var _g_head = cult.nodes.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var node = val;
			++power;
			if(node.isGenerator) {
				++power;
			}
		}
		var _g1 = 0;
		var _g2 = cult.power;
		while(_g1 < _g2.length) {
			var p = _g2[_g1];
			++_g1;
			power += p;
		}
		return power;
	}
	,findWeakestCult: function() {
		var cult = null;
		var cultPower = 10000;
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.isDead) {
				continue;
			}
			if(this.getCultPower(c) < cultPower) {
				cult = c;
				cultPower = this.getCultPower(c);
			}
		}
		return cult;
	}
	,debug: function(s) {
		if(Game.debugDirector) {
			console.log("Director.hx:121:",s);
		}
	}
};
var Game = $hx_exports["Game"] = function() {
	this.ui = new UI(this);
	if(UI.modernMode) {
		var _g = 0;
		var _g1 = Static.difficulty;
		while(_g < _g1.length) {
			var d = _g1[_g];
			++_g;
			d.mapWidth = d.mapWidth * UI.vars.scaleFactor | 0;
			d.mapHeight = d.mapHeight * UI.vars.scaleFactor | 0;
			d.nodeActivationRadius = d.nodeActivationRadius * UI.vars.scaleFactor | 0;
		}
	}
	this.isNeverStarted = true;
	this.isFinished = true;
	this.isTutorial = false;
	this.turns = 0;
};
Game.__name__ = true;
Game.main = function() {
	Game.instance = new Game();
	Game.instance.init();
};
Game.prototype = {
	init: function() {
		this.ui.init();
		this.director = new Director(this,this.ui);
		this.sectAdvisor = new sects_Advisor(this);
		this.ui.mainMenu.show();
		this.sectTasks = [];
		var _g = 0;
		var _g1 = sects_Sect.taskClasses;
		while(_g < _g1.length) {
			var cl = _g1[_g];
			++_g;
			var t = Type.createInstance(cl,[this,this.ui]);
			this.sectTasks.push(t);
		}
	}
	,onTutorialStart: function() {
		this.isTutorial = true;
		this.tutorial.play("start");
	}
	,restart: function(newDifficulty,newDif) {
		this.isNeverStarted = false;
		this.isTutorial = false;
		this.tutorial = new Tutorial(this,this.ui);
		var _this = this.ui.config;
		if(getCookie("hasPlayed") == null) {
			this.ui.alert("Welcome.<br><br>If this is your first time playing, do not hesitate to " + "consult the Manual if you have any questions. " + "We are not responsible for horrific deaths caused by ignoring the " + "Manual. You have been warned.");
		}
		this.ui.alert("Now available on Steam!<br><br><iframe src=\"https://store.steampowered.com/widget/1237260/\" frameborder=\"0\" style=\"padding-left:3%\" width=\"95%\" height=\"190\"></iframe>",{ h : 320});
		if(UI.modernMode && newDifficulty >= 0 && newDifficulty < 2) {
			this.ui.alert("Start the tutorial?",{ yesNo : true, onYes : $bind(this,this.onTutorialStart)});
		}
		var _this1 = this.ui.config;
		setCookie("hasPlayed","1",new Date(2015, 0, 0, 0, 0, 0, 0));
		var _this2 = this.ui;
		var action = "startGame diff:" + newDifficulty;
		var label = null;
		var value = null;
		action = "cult " + action + " " + Game.version;
		if(label == null) {
			label = "";
		}
		if(value == null) {
			value = 0;
		}
		if(Game.debugTime) {
			this.timerTime = window.performance.now();
		}
		this.difficultyLevel = newDifficulty;
		if(this.difficultyLevel >= 0) {
			this.difficulty = Static.difficulty[this.difficultyLevel];
		} else {
			this.difficulty = newDif;
		}
		this.isFinished = false;
		this.turns = 0;
		this.ui.map.initMinimap();
		this.ui.clearMap();
		this.ui.clearLog();
		if(Game.isDebug) {
			console.log("Game.hx:141:","nodeActivationRadius: " + this.difficulty.nodeActivationRadius);
		}
		this.lines = new haxe_ds_List();
		this.nodes = [];
		this.cults = [];
		this.lastCultID = 0;
		var cultInfo = [];
		var numPlayersLeft = this.difficulty.numPlayers;
		var _g = 0;
		var _g1 = this.difficulty.numCults;
		while(_g < _g1) {
			var i = _g++;
			var p = null;
			var id = this.lastCultID++;
			var infoID = 0;
			if(i > 0) {
				while(true) {
					infoID = 1 + (Math.random() * (Static.cults.length - 1) | 0);
					var ok = true;
					var _g2 = 0;
					while(_g2 < cultInfo.length) {
						var ii = cultInfo[_g2];
						++_g2;
						if(infoID == ii) {
							ok = false;
							break;
						}
					}
					if(ok) {
						break;
					}
				}
			}
			if(numPlayersLeft > 0) {
				p = new Cult(this,this.ui,id,infoID);
				--numPlayersLeft;
			} else {
				p = new AI(this,this.ui,id,infoID);
			}
			this.cults.push(p);
			cultInfo.push(infoID);
		}
		this.player = this.cults[0];
		this.currentPlayerID = 0;
		this.lastNodeIndex = 0;
		var _g21 = 1;
		var _g3 = this.difficulty.nodesCount + 1;
		while(_g21 < _g3) {
			var i1 = _g21++;
			this.spawnNode();
		}
		var toRemove = new haxe_ds_List();
		var _g4 = 0;
		var _g5 = this.nodes;
		while(_g4 < _g5.length) {
			var node = _g5[_g4];
			++_g4;
			var ok1 = false;
			var _g41 = 0;
			var _g51 = this.nodes;
			while(_g41 < _g51.length) {
				var n = _g51[_g41];
				++_g41;
				if(n != node && n.distance(node) < this.difficulty.nodeActivationRadius) {
					ok1 = true;
					break;
				}
			}
			if(!ok1) {
				toRemove.add(node);
			}
		}
		if(Game.isDebug && toRemove.length > 0) {
			console.log("Game.hx:205:",toRemove.length + " nodes removed");
		}
		var _g6_head = toRemove.h;
		while(_g6_head != null) {
			var val = _g6_head.item;
			_g6_head = _g6_head.next;
			var n1 = val;
			HxOverrides.remove(this.nodes,n1);
		}
		var cnt = 0.15 * this.difficulty.nodesCount | 0;
		var _g7 = 0;
		var _g8 = cnt;
		while(_g7 < _g8) {
			var i2 = _g7++;
			var nodeIndex = Std.random(this.nodes.length);
			var node1 = this.nodes[nodeIndex];
			node1.makeGenerator();
		}
		this.updateLinks();
		this.freeQuadrants = [];
		var _g9 = 0;
		while(_g9 < 4) {
			var i3 = _g9++;
			if(i3 == 0) {
				this.freeQuadrants.push({ x1 : 0, y1 : 0, x2 : this.difficulty.mapWidth / 2 | 0, y2 : this.difficulty.mapHeight / 2 | 0});
			} else if(i3 == 1) {
				this.freeQuadrants.push({ x1 : this.difficulty.mapWidth / 2 | 0, y1 : 0, x2 : this.difficulty.mapWidth, y2 : this.difficulty.mapHeight / 2 | 0});
			} else if(i3 == 2) {
				this.freeQuadrants.push({ x1 : 0, y1 : this.difficulty.mapHeight / 2 | 0, x2 : this.difficulty.mapWidth / 2 | 0, y2 : this.difficulty.mapHeight});
			} else if(i3 == 3) {
				this.freeQuadrants.push({ x1 : this.difficulty.mapWidth / 2 | 0, y1 : this.difficulty.mapHeight / 2 | 0, x2 : this.difficulty.mapWidth, y2 : this.difficulty.mapHeight});
			}
		}
		var _g10 = 0;
		var _g11 = this.cults;
		while(_g10 < _g11.length) {
			var c = _g11[_g10];
			++_g10;
			c.setOrigin();
		}
		if(this.difficulty.numPlayers == 1) {
			var _g12 = 0;
			var _g13 = OptionsMenu.elementInfo;
			while(_g12 < _g13.length) {
				var info = _g13[_g12];
				++_g12;
				var val1 = null;
				if(info.type == "bool") {
					val1 = this.ui.config.getBool(info.name);
				} else if(info.type == "int") {
					val1 = this.ui.config.getInt(info.name);
				}
				this.player.options.set(info.name,val1);
			}
		}
		this.ui.map.center(this.player.origin.x,this.player.origin.y);
		this.ui.status.update();
		var _g121 = 0;
		var _g131 = this.cults;
		while(_g121 < _g131.length) {
			var c1 = _g131[_g121];
			++_g121;
			c1.log("Game started.");
		}
		if(Game.debugTime) {
			console.log("Game.hx:583:","restart" + ": " + (window.performance.now() - this.timerTime) + "ms");
		}
	}
	,updateLinks: function() {
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g11 = this.nodes;
			while(_g2 < _g11.length) {
				var n2 = _g11[_g2];
				++_g2;
				if(n != n2 && n.distance(n2) <= this.difficulty.nodeActivationRadius) {
					n.links.remove(n2);
					n.links.add(n2);
				}
			}
		}
	}
	,spawnNode: function() {
		var x = 0;
		var y = 0;
		var cnt = 0;
		var sx = UI.vars.markerWidth * 2;
		var sy = UI.vars.markerHeight * 2;
		var d = UI.vars.markerWidth * 2;
		while(true) {
			x = Math.round(20 + Math.random() * (this.difficulty.mapWidth - UI.vars.markerWidth - 40));
			y = Math.round(20 + Math.random() * (this.difficulty.mapHeight - UI.vars.markerHeight - 40));
			++cnt;
			if(cnt > 100) {
				console.log("Game.hx:312:","could not spawn node");
				return;
			}
			var ok = 1;
			var _g = 0;
			var _g1 = this.nodes;
			while(_g < _g1.length) {
				var n = _g1[_g];
				++_g;
				if(n.distanceXY(x,y) < d) {
					ok = 0;
					break;
				}
			}
			if(ok == 1) {
				break;
			}
		}
		var node = new Node(this,this.ui,x,y,this.lastNodeIndex++);
		if(Game.mapVisible) {
			node.setVisible(this.player,true);
		}
		node.update();
		this.nodes.push(node);
	}
	,load: function(save) {
		this.isFinished = false;
		this.turns = 0;
		this.ui.clearMap();
		this.ui.clearLog();
		this.lines = new haxe_ds_List();
		this.nodes = [];
		this.cults = [];
		this.difficultyLevel = save.dif;
		this.difficulty = Static.difficulty[this.difficultyLevel];
		this.turns = save.turns;
		var savecults = save.cults;
		var _g = 0;
		while(_g < savecults.length) {
			var c = savecults[_g];
			++_g;
			var cult = null;
			if(c.ia == 0) {
				cult = new Cult(this,this.ui,c.id,c.iid);
				this.player = cult;
			} else {
				cult = new AI(this,this.ui,c.id,c.iid);
			}
			cult.load(c);
			this.cults.push(cult);
		}
		var savenodes = save.nodes;
		var _g1 = 0;
		while(_g1 < savenodes.length) {
			var n = savenodes[_g1];
			++_g1;
			var node = new Node(this,this.ui,n.x,n.y,n.id);
			node.load(n);
			this.nodes.push(node);
			if(node.owner == this.player) {
				node.isKnown[this.player.id] = true;
			}
		}
		this.updateLinks();
		var _g2 = 0;
		while(_g2 < savecults.length) {
			var c1 = savecults[_g2];
			++_g2;
			var _g21 = 0;
			var _g3 = this.cults;
			while(_g21 < _g3.length) {
				var cc = _g3[_g21];
				++_g21;
				if(c1.id == cc.id) {
					var n1 = this.getNode(c1.or);
					if(n1 != null) {
						cc.origin = n1;
					}
				}
			}
		}
		var _g31 = 0;
		var _g4 = this.nodes;
		while(_g31 < _g4.length) {
			var n2 = _g4[_g31];
			++_g31;
			n2.update();
		}
		var savelines = save.lines;
		var _g5 = 0;
		while(_g5 < savelines.length) {
			var l = savelines[_g5];
			++_g5;
			var startNode = this.getNode(l[0]);
			var endNode = this.getNode(l[1]);
			var cult1 = this.cults[l[2]];
			var line = Line.create(this.ui,cult1,startNode,endNode);
			console.log("Game.hx:413:","TODO: load lines visibility bug!");
			this.lines.add(line);
			startNode.lines.add(line);
			endNode.lines.add(line);
		}
		this.ui.status.update();
	}
	,save: function() {
		var save = { };
		save.nodes = [];
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			save.nodes.push(n.save());
		}
		save.cults = [];
		var _g2 = 0;
		var _g3 = this.cults;
		while(_g2 < _g3.length) {
			var c = _g3[_g2];
			++_g2;
			save.cults.push(c.save());
		}
		save.lines = [];
		console.log("Game.hx:437:","TODO: save lines fail");
		save.turns = this.turns;
		save.dif = this.difficultyLevel;
		return save;
	}
	,getNode: function(id) {
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			if(n.id == id) {
				return n;
			}
		}
		return null;
	}
	,endTurn: function() {
		var newPlayerID = -1;
		var _g = this.currentPlayerID + 1;
		var _g1 = this.cults.length;
		while(_g < _g1) {
			var i = _g++;
			var c = this.cults[i];
			if(c.isAI && !c.isDead) {
				var ai = this.cults[i];
				ai.turn();
				if(this.isFinished) {
					return;
				}
				var name = "ai " + ai.name;
				if(Game.debugTime) {
					this.timerTime = window.performance.now();
				}
				ai.aiTurn();
				if(Game.debugTime) {
					console.log("Game.hx:583:","ai " + ai.name + ": " + (window.performance.now() - this.timerTime) + "ms");
				}
			}
			if(!c.isAI && !c.isDead) {
				newPlayerID = i;
				break;
			}
		}
		if(newPlayerID >= 0) {
			this.player = this.cults[newPlayerID];
			this.currentPlayerID = newPlayerID;
			this.applyPlayerOptions();
			this.player.turn();
			var _g2 = 0;
			var _g3 = this.cults;
			while(_g2 < _g3.length) {
				var c1 = _g3[_g2];
				++_g2;
				c1.checkVictory();
			}
			if(this.difficulty.numPlayers > 1) {
				var x = 0;
				var y = 0;
				if(this.player.origin != null) {
					x = this.player.origin.x;
					y = this.player.origin.y;
				} else {
					var node = this.player.nodes.first();
					var _g4_head = this.player.nodes.h;
					while(_g4_head != null) {
						var val = _g4_head.item;
						_g4_head = _g4_head.next;
						var n = val;
						if(n.level > node.level) {
							node = n;
						}
					}
					x = node.x;
					y = node.y;
				}
				this.ui.map.center(x,y);
			}
			this.ui.logPanel.paint();
			this.ui.status.update();
			this.ui.map.paint();
			if(this.difficulty.numPlayers > 1) {
				this.ui.alert("Your turn<br>" + this.player.get_fullName(),{ w : 400, h : 125, shadowOpacity : 1});
			}
		}
		if(newPlayerID < 0) {
			this.turns++;
			this.currentPlayerID = -1;
			this.director.turn();
			this.endTurn();
		}
		this.tutorial.play("endTurn");
		if(this.player.awareness >= 10) {
			this.tutorial.play("awareness");
		}
	}
	,failSectTasks: function() {
		var _g = 0;
		var _g1 = this.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var _g_head = c.sects.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var s = val;
				if(s.task != null && s.task.checkFailure(s) == true) {
					s.clearTask();
				}
			}
		}
	}
	,applyPlayerOptions: function() {
		this.ui.map.paint();
	}
	,startTimer: function(name) {
		if(Game.debugTime) {
			this.timerTime = window.performance.now();
		}
	}
	,endTimer: function(name) {
		if(Game.debugTime) {
			console.log("Game.hx:583:",name + ": " + (window.performance.now() - this.timerTime) + "ms");
		}
	}
};
var GenName = function() { };
GenName.__name__ = true;
GenName.generate = function(gender) {
	var nn = gender ? GenName.namesFemale : GenName.namesMale;
	var nat = Std.random(nn.length);
	var name = nn[nat][Std.random(nn[nat].length)];
	var surname = GenName.surnames[nat][Std.random(GenName.surnames[nat].length)];
	return name + " " + surname;
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.dateStr = function(date) {
	var m = date.getMonth() + 1;
	var d = date.getDate();
	var h = date.getHours();
	var mi = date.getMinutes();
	var s = date.getSeconds();
	return date.getFullYear() + "-" + (m < 10 ? "0" + m : "" + m) + "-" + (d < 10 ? "0" + d : "" + d) + " " + (h < 10 ? "0" + h : "" + h) + ":" + (mi < 10 ? "0" + mi : "" + mi) + ":" + (s < 10 ? "0" + s : "" + s);
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
var Info = function(uivar,gvar) {
	Window.call(this,uivar,gvar,"cultInfo",800,536,20,493);
	this.text = window.document.createElement("div");
	this.text.className = "uiText";
	this.text.style.fontSize = "16px";
	this.window.appendChild(this.text);
};
Info.__name__ = true;
Info.e = function(s) {
	return window.document.getElementById(s);
};
Info.__super__ = Window;
Info.prototype = $extend(Window.prototype,{
	onShow: function() {
		var s = "";
		var i = 0;
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			s += "<div class=\"cultInfoBlock\" style=\"" + (i == 0 ? "background:var(--text-select-bg)" : "") + "\">";
			if(p.isDead) {
				s += "<s>";
			}
			s += p.isDiscovered[this.game.player.id] ? p.get_fullName() : "?";
			if(p.isDead) {
				s += "</s> Forgotten";
			}
			if(!p.isDead && p.isInfoKnown[this.game.player.id]) {
				var w = "";
				var _g2 = 0;
				var _g11 = p.wars.length;
				while(_g2 < _g11) {
					var i1 = _g2++;
					if(p.wars[i1]) {
						w += UI.cultName(i1,this.game.cults[i1].info) + " ";
					}
				}
				if(w != "") {
					s += " wars: " + w;
				}
			}
			s += "<br>";
			if(p.hasInvestigator && p.isInfoKnown[this.game.player.id]) {
				s += "<span class=cultInfoInv1>Investigator <span class=cultInfoInv2>" + p.investigator.name + "</span>";
				if(!p.investigator.isHidden) {
					s += ": Level " + (p.investigator.level + 1) + ", Willpower " + p.investigator.will;
				}
				s += "</span>";
				if(p.investigator.isHidden) {
					s += " <span class=cultInfoInv2>--- Hidden ---</span>";
				}
				s += "<br>";
			}
			if(Game.isDebug && p.investigatorTimeout > 0 && p.isInfoKnown[this.game.player.id]) {
				s += " Investigator timeout: " + p.investigatorTimeout + "<br>";
			}
			if(Game.isDebug) {
				s += this.getDebugInfo(p,false);
			}
			if(p.isRitual && p.isInfoKnown[this.game.player.id]) {
				var turns = p.ritualPoints / p.get_priests() | 0;
				if(p.ritualPoints % p.get_priests() > 0) {
					++turns;
				}
				s += "Casting <span class=shadow title='" + p.ritual.note + "' id='info.ritual" + i + "' style='color:#ffaaaa'>" + p.ritual.name + "</span>, " + (p.ritual.points - p.ritualPoints) + "/" + p.ritual.points + " points, " + turns + " turns left<br>";
			}
			if(!p.isDead && p.isInfoKnown[this.game.player.id]) {
				s += p.nodes.length + " followers (" + p.get_neophytes() + " neophytes, " + p.get_adepts() + " adepts, " + p.get_priests() + " priests)";
				if(p.isParalyzed) {
					s += " --- Paralyzed ---";
				}
				s += "<br>";
			}
			s += "<span id='info.toggleNote" + i + "' style='height:10; width:10; font-size:12px; border: 1px solid #777'>+</span>";
			s += "<br>";
			s += "<span id='info.note" + i + "'>" + (p.isInfoKnown[this.game.player.id] ? p.info.note : "No information.") + "</span>";
			s += "<span id='info.longnote" + i + "'>" + (p.isInfoKnown[this.game.player.id] ? p.info.longNote : "No information.") + "</span>";
			s += "</div><hr>";
			++i;
		}
		this.text.innerHTML = s;
		this.bg.style.display = "inline";
		this.window.style.display = "inline";
		this.isVisible = true;
		var _g21 = 0;
		var _g3 = this.game.difficulty.numCults;
		while(_g21 < _g3) {
			var i2 = _g21++;
			var p1 = this.game.cults[i2];
			new JQuery("#info\\.ritual" + i2).tooltip({ delay : 0});
			window.document.getElementById("info.longnote" + i2).style.display = "none";
			var c = window.document.getElementById("info.toggleNote" + i2);
			c.style.cursor = "pointer";
			c.noteID = i2;
			c.onclick = function(event) {
				var t = event.target;
				if(t.innerHTML == "+") {
					t.innerHTML = "&mdash;";
					window.document.getElementById("info.longnote" + Std.string(t.noteID)).style.display = "block";
					window.document.getElementById("info.note" + Std.string(t.noteID)).style.display = "none";
				} else {
					t.innerHTML = "+";
					window.document.getElementById("info.longnote" + Std.string(t.noteID)).style.display = "none";
					window.document.getElementById("info.note" + Std.string(t.noteID)).style.display = "block";
				}
			};
		}
	}
	,getDebugInfo: function(p,status) {
		var s = "<span style='font-size: 10px'>";
		var _g = 0;
		var _g1 = p.power.length;
		while(_g < _g1) {
			var i = _g++;
			s += UI.powerName(i,true) + ": " + p.power[i] + " (";
			if(i < 3) {
				s += "+0-" + p.powerMod[i] + ", " + p.getResourceChance() + "%), ";
			} else {
				s += "+0-" + p.maxVirgins() + "), ";
			}
			if(status) {
				s += "<br>";
			}
		}
		s += "<span title='Awareness'>A: " + p.awareness + "%</span>, ";
		if(status) {
			s += "<br>";
		}
		s += "<span title='Chance of summoning'>ROS: " + p.getUpgradeChance(2) + "%</span>, ";
		if(status) {
			s += "<br>";
		}
		if(!p.hasInvestigator) {
			s += "<span title='Chance of investigator appearing'>IAC: " + p.getInvestigatorChance() + "%</span>, ";
		}
		if(p.hasInvestigator) {
			s += "<span title='Chance of investigator reveal'>IRC: " + p.investigator.getKillChance() + "%</span>, ";
			s += "<span title='Chance of lowering investigator willpower'>IWLC: " + p.investigator.getGainWillChance() + "%</span>, ";
			s += "<span title='Chance of investigator willpower raise'>IWC: " + p.getLowerWillChance() + "%</span>, ";
		}
		if(status) {
			s += "<br>";
		}
		s += "<span title='Cult Power'>PWR:&nbsp;" + this.game.director.getCultPower(p) + "</span>, ";
		s += "Dif: " + p.difficulty.level;
		s += "</span><br>";
		return s;
	}
});
var Investigator = function(c,ui,g) {
	this.cult = c;
	this.ui = ui;
	this.game = g;
	this.gender = Std.random(2) == 0 ? false : true;
	this.name = GenName.generate(this.gender);
	this.numTurn = 0;
	this.isHidden = true;
	this.will = 1 + (c.nodes.length * c.difficulty.investigatorCultSize | 0);
	if(this.will > 9) {
		this.will = 9;
	}
	if(this.cult.isAI && this.will > 4) {
		this.will = 4;
	}
	this.level = this.will / 3 | 0;
	if(this.level > 2) {
		this.level = 2;
	}
};
Investigator.__name__ = true;
Investigator.prototype = {
	load: function(obj) {
		this.name = obj.n;
		this.will = obj.w;
		this.level = obj.l;
		this.isHidden = obj.h == 1;
	}
	,save: function() {
		return { n : this.name, w : this.will, l : this.level, h : this.isHidden ? 1 : 0};
	}
	,turn: function() {
		if(this.numTurn == 0) {
			this.numTurn++;
			return;
		}
		var turnVisible = this.cult.difficulty.investigatorTurnVisible;
		if(this.cult.isAI && turnVisible > 0) {
			turnVisible = 2;
		}
		if(this.isHidden && this.numTurn > turnVisible) {
			this.ui.log2(this.cult,this.cult.get_fullName() + " has found out the investigator's location.",{ symbol : "I"});
			this.isHidden = false;
		}
		if(this.will >= 9) {
			this.isHidden = true;
		}
		this.numTurn++;
		var _g = 0;
		var _g1 = this.level + 1;
		while(_g < _g1) {
			var i = _g++;
			this.killFollower();
		}
		if(this.cult.awareness < 5 && !this.cult.isRitual) {
			return;
		}
		this.gainWill();
		if(this.cult.isRitual && 100 * Math.random() < 30) {
			this.gainWill();
		}
	}
	,gainWill: function() {
		if(100 * Math.random() > this.getGainWillChance()) {
			return;
		}
		var oldLevel = this.level;
		this.will += 1;
		this.level = this.will / 3 | 0;
		if(this.level > 2) {
			this.level = 2;
		}
		if(this.level > oldLevel && !this.cult.isAI) {
			this.ui.log2(this.cult,"The investigator of " + this.cult.get_fullName() + " has gained level " + (this.level + 1) + ".",{ symbol : "I"});
		}
	}
	,killFollower: function() {
		if(100 * Math.random() > this.getKillChance()) {
			return;
		}
		var node = null;
		if(this.cult.isRitual) {
			var _g_head = this.cult.nodes.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var n = val;
				if(n.level > this.level || n.isProtected) {
					continue;
				}
				if(node != null && n.level <= node.level) {
					continue;
				}
				node = n;
			}
		} else {
			var _g_head1 = this.cult.nodes.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var n1 = val1;
				if(n1.level > this.level || n1.isProtected) {
					continue;
				}
				node = n1;
				if(Math.random() > 0.5) {
					break;
				}
			}
		}
		if(node == null) {
			return;
		}
		if(node == this.cult.origin && Math.random() > 0.3) {
			return;
		}
		this.ui.log2(this.cult,"The investigator revealed the " + this.cult.get_fullName() + " follower.",{ symbol : "I"});
		if(node.sect != null) {
			this.cult.removeSect(node,"investigator");
		}
		node.generateAttributes();
		node.removeOwner();
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(node.visibility[c.id]) {
				c.highlightNode(node);
			}
		}
	}
	,lowerWillpower: function(val) {
		this.will -= val;
		if(this.will > 0) {
			return;
		}
		this.ui.log2(this.cult,"The investigator of the " + this.cult.get_fullName() + " has disappeared.",{ symbol : "I"});
		this.cult.killInvestigator();
	}
	,getGainWillChance: function() {
		var chance = 70 * this.cult.difficulty.investigatorGainWill | 0;
		var _g_head = this.cult.sects.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var sect = val;
			if(sect.task == null || sect.task.id != "invConfuse") {
				continue;
			}
			if(sect.level == 0) {
				chance -= 2;
			} else if(sect.level == 1) {
				chance -= 5;
			} else if(sect.level == 2) {
				chance -= 10;
			}
		}
		if(chance < 20) {
			chance = 20;
		}
		return chance;
	}
	,getKillChance: function() {
		var chance = 0;
		if(this.cult.awareness <= 5) {
			chance = 20 * this.cult.difficulty.investigatorKill | 0;
		} else if(this.cult.awareness <= 10) {
			chance = 50 * this.cult.difficulty.investigatorKill | 0;
		} else {
			chance = 70 * this.cult.difficulty.investigatorKill | 0;
		}
		var _g_head = this.cult.sects.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var sect = val;
			if(sect.task == null || sect.task.id != "invConfuse") {
				continue;
			}
			if(sect.level == 0) {
				chance -= 2;
			} else if(sect.level == 1) {
				chance -= 5;
			} else if(sect.level == 2) {
				chance -= 10;
			}
		}
		if(chance < 5) {
			chance = 5;
		}
		return chance;
	}
};
var Line = function(ui) {
	this.ui = ui;
	this.map = ui.map;
	this.pixels = [];
};
Line.__name__ = true;
Line.create = function(ui,player,startNode,endNode) {
	var line = new Line(ui);
	line.owner = player;
	line.startNode = startNode;
	line.endNode = endNode;
	line.visibility = [false,false,false,false];
	if(UI.classicMode) {
		var cnt = 10;
		var dist = startNode.distance(endNode);
		if(dist < 50) {
			cnt = (dist / 6 | 0) + 1;
		}
		var x = startNode.centerX;
		var y = startNode.centerY;
		var modx = (endNode.centerX - startNode.centerX) / cnt;
		var mody = (endNode.centerY - startNode.centerY) / cnt;
		var _g = 1;
		var _g1 = cnt;
		while(_g < _g1) {
			var i = _g++;
			x += modx;
			y += mody;
			line.pixels.push({ x : Math.round(x), y : Math.round(y)});
		}
	}
	return line;
};
Line.prototype = {
	paint: function(ctx,cultID) {
		if(!this.visibility[cultID]) {
			return;
		}
		if(UI.classicMode) {
			var _g = 0;
			var _g1 = this.pixels;
			while(_g < _g1.length) {
				var p = _g1[_g];
				++_g;
				if(p.x < this.map.viewRect.x - 2 || p.y < this.map.viewRect.y - 2 || p.x > this.map.viewRect.x + this.map.viewRect.w || p.y > this.map.viewRect.y + this.map.viewRect.h) {
					continue;
				}
				ctx.drawImage(this.map.nodeImage,this.owner.id * 2,120,2,2,p.x - this.map.viewRect.x,p.y - this.map.viewRect.y,2,2);
			}
		} else {
			var out = 0;
			if(!this.startNode.uiNode.inViewRect(200)) {
				++out;
			}
			if(!this.endNode.uiNode.inViewRect(200)) {
				++out;
			}
			if(out == 2) {
				return;
			}
			ctx.strokeStyle = UI.vars.cultColors[this.owner.id];
			ctx.lineWidth = 3 * this.ui.map.zoom;
			ctx.beginPath();
			ctx.moveTo(this.ui.map.zoom * (this.startNode.centerX - this.map.viewRect.x),this.ui.map.zoom * (this.startNode.centerY - this.map.viewRect.y));
			ctx.lineTo(this.ui.map.zoom * (this.endNode.centerX - this.map.viewRect.x),this.ui.map.zoom * (this.endNode.centerY - this.map.viewRect.y));
			ctx.stroke();
		}
	}
	,setVisible: function(c,vis) {
		this.visibility[c.id] = vis;
	}
	,clear: function() {
		this.pixels = null;
	}
};
var LoadMenu = function(uivar,gvar) {
	this.ui = uivar;
	this.game = gvar;
	this.isVisible = false;
	this.window = Tools.window({ id : "loadMenuWindow", w : 420, h : 320, z : 25});
	Tools.label({ id : "loadLabel", text : "Key", w : 60, h : 30, x : 35, y : 30, container : this.window});
	var _this = this.ui.config;
	this.key = Tools.textfield({ id : "loadKey", text : getCookie("owner"), w : 205, h : 30, x : 85, y : 30, container : this.window});
	this.key.onclick = $bind(this,this.onKeyClick);
	Tools.button({ id : "loadRefresh", text : "Refresh", w : 100, h : 30, x : 300, y : 30, container : this.window, func : $bind(this,this.onRefresh)});
	this.noSavesFound = Tools.label({ id : "loadLabel2", text : "No saves found.", w : 200, h : 30, x : 140, y : 150, container : this.window});
	this.saves = [];
	this.saveButtons = [];
	this.delButtons = [];
	var _g = 0;
	var _g1 = UI.maxSaves;
	while(_g < _g1) {
		var i = _g++;
		var b = Tools.button({ id : "load" + i, text : "Load", w : 330, h : 30, x : 35, y : 70 + 40 * i, container : this.window, func : $bind(this,this.onLoadGame)});
		this.saveButtons.push(b);
		var b2 = Tools.button({ id : "del" + i, text : "X", w : 20, h : 30, x : 380, y : 70 + 40 * i, container : this.window, func : $bind(this,this.onDelGame)});
		this.delButtons.push(b2);
	}
	this.bg = Tools.bg();
	var container = this.window;
	var w = Std.parseInt(container.style.width);
	var b1 = Tools.button({ id : null, text : "Close", w : 80, h : null, x : null, y : null, container : container});
	b1.style.left = "50%";
	b1.style.bottom = "var(--close-button-bottom)";
	b1.style.transform = "translate(-50%)";
	this.close = b1;
	this.close.onclick = $bind(this,this.onClose);
};
LoadMenu.__name__ = true;
LoadMenu.prototype = {
	show: function() {
		var list = [];
		var _this = this.ui.config;
		if(getCookie("owner") != "") {
			var req = new XMLHttpRequest();
			var _this1 = this.ui.config;
			req.open("GET","/save.list?owner=" + getCookie("owner"),false);
			req.send(null);
			var text = req.responseText;
			list = JSON.parse(text);
		}
		this.saves = list;
		var i = 0;
		var _g = 0;
		var _g1 = this.saveButtons;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.style.display = "none";
			this.delButtons[i].style.display = "none";
			++i;
		}
		i = 0;
		this.noSavesFound.style.display = "inline";
		var _g2 = 0;
		while(_g2 < list.length) {
			var item = list[_g2];
			++_g2;
			var b1 = this.saveButtons[i];
			if(b1 == null) {
				break;
			}
			b1.innerHTML = item.name;
			b1.style.display = "inline";
			this.delButtons[i].style.display = "inline";
			++i;
			this.noSavesFound.style.display = "none";
		}
		var _this2 = this.ui.config;
		var tmp = getCookie("owner");
		this.key.value = tmp;
		this.window.style.display = "inline";
		this.bg.style.display = "inline";
		this.close.style.display = "inline";
		this.isVisible = true;
		this.keyFocused = false;
	}
	,onKeyClick: function() {
		this.keyFocused = true;
	}
	,onRefresh: function(event) {
		var _this = this.ui.config;
		var val = this.key.value;
		setCookie("owner",val,new Date(2015, 0, 0, 0, 0, 0, 0));
		this.show();
	}
	,onLoadGame: function(event) {
		var b = Tools.getTarget(event);
		var n = Std.parseInt(b.id.substring(4));
		this.onLoadReal(n);
	}
	,onLoadReal: function(n) {
		var save = this.saves[n];
		var req = new XMLHttpRequest();
		var _this = this.ui.config;
		req.open("GET","/save.load?owner=" + getCookie("owner") + "&id=" + save.id,false);
		req.send(null);
		var text = req.responseText;
		if(text == "NoSuchSave") {
			return;
		}
		var savedGame = JSON.parse(text);
		this.game.load(savedGame);
		this.onClose(null);
	}
	,onDelGame: function(event) {
		var b = Tools.getTarget(event);
		var n = Std.parseInt(b.id.substring(3));
		this.onDelReal(n);
	}
	,onDelReal: function(n) {
		var save = this.saves[n];
		var req = new XMLHttpRequest();
		var _this = this.ui.config;
		req.open("GET","/save.delete?owner=" + getCookie("owner") + "&id=" + save.id,false);
		req.send(null);
		var text = req.responseText;
		this.show();
	}
	,onKey: function(e) {
		if(this.keyFocused) {
			return;
		}
		if(e.keyCode == 49) {
			this.onLoadReal(0);
		} else if(e.keyCode == 50) {
			this.onLoadReal(1);
		} else if(e.keyCode == 51) {
			this.onLoadReal(2);
		} else if(e.keyCode == 52) {
			this.onLoadReal(3);
		} else if(e.keyCode == 53) {
			this.onLoadReal(4);
		} else if(e.keyCode == 27) {
			this.onClose(null);
		}
	}
	,onClose: function(event) {
		this.window.style.display = "none";
		this.bg.style.display = "none";
		this.close.style.display = "none";
		this.noSavesFound.style.display = "none";
		var _g = 0;
		var _g1 = this.saveButtons;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.style.display = "none";
		}
		var _g2 = 0;
		var _g3 = this.delButtons;
		while(_g2 < _g3.length) {
			var b1 = _g3[_g2];
			++_g2;
			b1.style.display = "none";
		}
		this.isVisible = false;
	}
};
var Log = function(uivar,gvar) {
	Window.call(this,uivar,gvar,"log",800,536,20,493);
	var logBG = window.document.createElement("div");
	logBG.id = "logBGIMG";
	this.window.appendChild(logBG);
	var logFG = window.document.createElement("div");
	logFG.id = "logFG";
	logFG.className = "uiTextFG";
	logBG.appendChild(logFG);
	this.text = window.document.createElement("div");
	this.text.style.fontSize = "16px";
	this.text.style.padding = "10px";
	this.text.id = "logText";
	logFG.appendChild(this.text);
};
Log.__name__ = true;
Log.__super__ = Window;
Log.prototype = $extend(Window.prototype,{
	getRenderedMessage: function(s) {
		return "<span style='color:var(--text-color-log-time)'>" + DateTools.format(new Date(),"%H:%M:%S") + "</span>" + " Turn " + (this.game.turns + 1) + ": " + s + "<br>";
	}
	,clear: function() {
		this.text.innerHTML = "";
	}
	,onShow: function() {
		this.text.innerHTML = this.game.player.logMessages;
		this.text.scrollTop = 10000;
	}
});
var LogPanel = function(uivar,gvar) {
	this.ui = uivar;
	this.game = gvar;
	this.list = new haxe_ds_List();
	this.panel = window.document.createElement("div");
	this.panel.id = "logPanel";
	window.document.body.appendChild(this.panel);
};
LogPanel.__name__ = true;
LogPanel.prototype = {
	paint: function() {
		this.clear();
		var _g_head = this.game.player.logPanelMessages.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var m = val;
			var sym = "";
			var col = UI.modernMode ? "#d6d6d6" : "#303030";
			if(m.type == "cult" || m.type == null) {
				var cult = m.obj;
				col = UI.vars.lineColors[cult.id] + (UI.modernMode ? "e0" : "b0");
			} else if(m.type == "cults") {
				var cult1 = m.obj.c1;
				var cult2 = m.obj.c2;
				var ch = UI.modernMode ? "I" : "!";
				sym = "<span class=shadow style='color:" + UI.vars.lineColors[cult1.id] + "'>" + ch + "</span>" + "<span class=shadow style='color:" + UI.vars.lineColors[cult2.id] + "'>" + ch + "</span>";
			}
			if(m.params != null && m.params.symbol != null) {
				sym = m.params.symbol;
			}
			var e = window.document.createElement("div");
			m.id = this.list.length;
			e.id = "log.id" + this.list.length;
			e.className = "uiButton shadow " + (m.old ? "logPanelItemOld" : "logPanelItemNew");
			e.style.background = col;
			e.messageID = m.id;
			e.style.top = "" + this.list.length * 22;
			e.innerHTML = sym;
			this.panel.appendChild(e);
			e.onclick = $bind(this,this.onClick);
			e.title = "Turn " + m.turn + ": " + m.text;
			new JQuery("#log\\.id" + this.list.length).tooltip({ delay : 0});
			this.list.add(e);
		}
	}
	,onClick: function(event) {
		var e = Tools.getTarget(event);
		if(e.parentNode != this.panel) {
			e = e.parentNode;
		}
		this.panel.removeChild(e);
		this.list.remove(e);
		var _g_head = this.game.player.logPanelMessages.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var m = val;
			if(m.id == e.messageID) {
				this.game.player.logPanelMessages.remove(m);
			}
		}
		var cnt = 0;
		var nodes = this.panel.childNodes;
		var _g1 = 0;
		var _g2 = nodes.length;
		while(_g1 < _g2) {
			var i = _g1++;
			var el = nodes[i];
			el.style.top = cnt * 24 + "px";
			++cnt;
		}
	}
	,clear: function() {
		this.list.clear();
		while(this.panel.hasChildNodes()) this.panel.removeChild(this.panel.firstChild);
	}
};
var MainMenu = function(uivar,gvar) {
	var h = 280;
	var closeY = 240;
	Window.call(this,uivar,gvar,"mainMenu",420,h,20,closeY);
	Tools.label({ id : "mainMenuTitle", text : "EVIL&nbsp;&nbsp;CULT <span id=titleVersion>" + Game.version + "</span>", w : 260, h : 30, x : null, y : null, fontSize : null, container : this.window});
	var x = UI.classicMode ? 26 : 36;
	var y = UI.classicMode ? 40 : 47;
	var d = UI.classicMode ? 38 : 40;
	Tools.button({ id : "newGameEasy", text : "START NEW GAME - EASY", className : "uiButton statusButton mainMenuButton", w : null, h : null, x : x, y : y, container : this.window, func : $bind(this,this.onNewGame)});
	y += d;
	Tools.button({ id : "newGameNormal", text : "START NEW GAME - NORMAL", className : "uiButton statusButton mainMenuButton", w : null, h : null, x : x, y : y, container : this.window, func : $bind(this,this.onNewGame)});
	y += d;
	Tools.button({ id : "newGameHard", text : "START NEW GAME - HARD", className : "uiButton statusButton mainMenuButton", w : null, h : null, x : x, y : y, container : this.window, func : $bind(this,this.onNewGame)});
	y += d;
	Tools.button({ id : "customGame", text : "CUSTOM GAME", className : "uiButton statusButton mainMenuButton", w : null, h : null, x : x, y : y, container : this.window, func : $bind(this,this.onCustomGame)});
	y += d;
	Tools.button({ id : "customGame", text : "MULTIPLAYER GAME", className : "uiButton statusButton mainMenuButton", w : null, h : null, x : x, y : y, container : this.window, func : $bind(this,this.onMultiplayerGame)});
	y += d;
};
MainMenu.__name__ = true;
MainMenu.__super__ = Window;
MainMenu.prototype = $extend(Window.prototype,{
	onShow: function() {
		this.close.style.visibility = this.game.isNeverStarted ? "hidden" : "visible";
	}
	,onCustomGame: function(event) {
		this.ui.customMenu.show();
		this.onClose(null);
	}
	,onMultiplayerGame: function(event) {
		this.ui.mpMenu.show();
		this.onClose(null);
	}
	,onLoadGame: function(event) {
		this.ui.loadMenu.show();
		this.onClose(null);
	}
	,onSaveGame: function(event) {
		this.ui.saveMenu.show();
		this.onClose(null);
	}
	,onNewGame: function(event) {
		var id = Tools.getTarget(event).id;
		var dif = 0;
		if(id == "newGameEasy") {
			dif = 0;
		} else if(id == "newGameNormal") {
			dif = 1;
		} else {
			dif = 2;
		}
		this.onNewGameReal(dif);
	}
	,onNewGameReal: function(dif) {
		this.game.restart(dif);
		this.onClose(null);
	}
	,onKey: function(e) {
		if(e.keyCode == 49) {
			this.onNewGameReal(0);
		} else if(e.keyCode == 50) {
			this.onNewGameReal(1);
		} else if(e.keyCode == 51) {
			this.onNewGameReal(2);
		} else if(e.keyCode == 52) {
			this.onCustomGame(null);
		} else if(e.keyCode == 53) {
			this.onMultiplayerGame(null);
		} else if(e.keyCode == 27 && !this.game.isNeverStarted) {
			this.onClose(null);
		}
	}
});
var Manual = function(uivar,gvar) {
	Window.call(this,uivar,gvar,"manual",800,536,20,493);
	this.text = window.document.createElement("div");
	this.text.className = "uiText";
	this.text.style.fontSize = "14px";
	this.window.appendChild(this.text);
};
Manual.__name__ = true;
Manual.__super__ = Window;
Manual.prototype = $extend(Window.prototype,{
	onShow: function() {
		this.text.scrollTop = 0;
	}
});
var MapUI = function(uivar,gvar) {
	var _gthis = this;
	this.ui = uivar;
	this.game = gvar;
	this.viewRect = { x : 0, y : 0, w : 200, h : 200};
	this.bgImage = null;
	this.firstTime = true;
	this.isDrag = false;
	this.zoom = 1.0;
	this.minZoom = 0.25;
	this.powerColors = [];
	var _g = 0;
	var _g1 = Game.numPowers;
	while(_g < _g1) {
		var i = _g++;
		this.powerColors[i] = window.getComputedStyle(window.document.documentElement).getPropertyValue("--power-color-" + i);
	}
	this.mapBorder = window.document.getElementById("mapBorder");
	this.map = window.document.getElementById("map");
	this.mapWidth = 200;
	this.mapHeight = 200;
	this.map.onclick = $bind(this,this.onClick);
	this.map.onmousemove = $bind(this,this.onMouseMove);
	this.map.onmousedown = $bind(this,this.onMouseDown);
	this.map.onmouseup = $bind(this,this.onMouseUp);
	this.map.onmouseout = $bind(this,this.onMouseOut);
	window.document.onmouseout = function(event) {
		if(event.relatedTarget == null) {
			_gthis.isDrag = false;
		}
	};
	if(UI.modernMode) {
		this.map.onwheel = $bind(this,this.onWheel);
	}
	this.tooltip = Tools.window({ id : "mapTooltip", fontSize : 16, w : null, h : null, z : 3000, border : false});
	this.tooltip.style.display = "none";
	this.loadImages();
};
MapUI.__name__ = true;
MapUI.prototype = {
	initMinimap: function() {
		this.minimap = window.document.createElement("canvas");
		this.minimap.id = "minimap";
		this.minimap.width = this.game.difficulty.mapWidth * 100.0 / this.game.difficulty.mapHeight | 0;
		this.minimap.height = 100;
	}
	,loadImages: function() {
		this.nodeImage = new Image();
		this.nodeImage.onload = $bind(this,this.onLoadImage);
		this.nodeImage.src = "data/nodes.png";
		this.fontImage = new Image();
		this.fontImage.onload = $bind(this,this.onLoadImage);
		this.fontImage.src = "data/5x8.png";
		if(UI.modernMode) {
			this.loadImagesModern();
		}
	}
	,loadImagesModern: function() {
		this.bgImage = new Image();
		this.bgImage.onload = $bind(this,this.onLoadImage);
		this.bgImage.src = "data/bg.png";
		this.nodeImages = [];
		var _g = 0;
		while(_g < 9) {
			var i = _g++;
			var c = window.document.createElement("canvas");
			c.width = UI.vars.markerWidth;
			c.height = UI.vars.markerHeight;
			var cx = c.width / 2 | 0;
			var cy = c.height / 2 | 0;
			var r = cx;
			var n = c.getContext("2d",null);
			n.beginPath();
			n.arc(cx,cy,r,0,2 * Math.PI);
			n.fillStyle = UI.vars.cultColors[i];
			n.fill();
			n.beginPath();
			n.arc(cx - 1,cy + 2,r - 5,0,2 * Math.PI);
			n.fillStyle = "#f5efe1";
			n.fill();
			var clx = 44;
			var cly = 8;
			var rs = 8;
			n.beginPath();
			n.arc(clx,cly,rs,0,2 * Math.PI);
			n.fillStyle = UI.vars.cultColors[i];
			n.fill();
			n.beginPath();
			n.arc(clx,cly,rs - 1,0,2 * Math.PI);
			n.fillStyle = "#f5efe1";
			n.fill();
			this.nodeImages[i] = c;
		}
		this.nodeImagesGenerator = [];
		var _g1 = 0;
		while(_g1 < 9) {
			var i1 = _g1++;
			var c1 = window.document.createElement("canvas");
			c1.width = UI.vars.markerWidth;
			c1.height = UI.vars.markerHeight;
			var cx1 = c1.width / 2 | 0;
			var cy1 = c1.height / 2 | 0;
			var r1 = cx1;
			var n1 = c1.getContext("2d",null);
			n1.beginPath();
			n1.arc(cx1,cy1,r1,0,2 * Math.PI);
			n1.fillStyle = UI.vars.cultColors[i1];
			n1.fill();
			n1.beginPath();
			n1.arc(cx1 - 1,cy1 + 2,r1 - 5,0,2 * Math.PI);
			n1.fillStyle = "#ffffff40";
			if(UI.modernGeneratorColors[i1] != null) {
				n1.fillStyle = "#ffffff" + UI.modernGeneratorColors[i1][1];
			}
			n1.fill();
			n1.beginPath();
			n1.arc(cx1 - 3,cy1 + 6,r1 - 12,0,2 * Math.PI);
			n1.fillStyle = "#ffffff70";
			if(UI.modernGeneratorColors[i1] != null) {
				n1.fillStyle = "#ffffff" + UI.modernGeneratorColors[i1][2];
			}
			n1.fill();
			var clx1 = 44;
			var cly1 = 8;
			var rs1 = 8;
			n1.beginPath();
			n1.arc(clx1,cly1,rs1,0,2 * Math.PI);
			n1.fillStyle = UI.vars.cultColors[i1];
			n1.fill();
			n1.beginPath();
			n1.arc(clx1,cly1,rs1 - 1,0,2 * Math.PI);
			n1.fillStyle = "#f5efe1";
			n1.fill();
			this.nodeImagesGenerator[i1] = c1;
		}
		this.jobImages = [];
		var _g2 = 0;
		var _g3 = UINode.jobInfo;
		while(_g2 < _g3.length) {
			var info = _g3[_g2];
			++_g2;
			var img = new Image();
			img.src = "data/" + info.img;
			img.width = info.w;
			img.height = info.h;
			this.jobImages.push(img);
		}
		this.powerImages = [];
		var _g4 = 0;
		var _g5 = UI.modernPowerImages;
		while(_g4 < _g5.length) {
			var name = _g5[_g4];
			++_g4;
			var img1 = new Image();
			img1.src = "data/" + name + "-map.png";
			img1.width = 15;
			img1.height = 15;
			this.powerImages.push(img1);
		}
		this.nodeHL = new Image();
		this.nodeHL.src = "data/highlight.png";
		this.nodeHL.width = 80;
		this.nodeHL.height = 80;
		this.jobImages.push(this.nodeHL);
	}
	,loadTextImages: function() {
		this.textImages = [];
		var text = ["?","S","1","2","3","-"];
		var _g = 0;
		var _g1 = text.length;
		while(_g < _g1) {
			var i = _g++;
			var c = window.document.createElement("canvas");
			c.width = 11;
			c.height = 13;
			var r = c.getContext("2d",null);
			r.textBaseline = "top";
			r.textAlign = "left";
			r.font = "bold 14px Mitr";
			r.fillStyle = "black";
			r.fillText(text[i],text[i] == "1" ? 2 : 1,1);
			this.textImages[i] = c;
		}
	}
	,onLoadImage: function() {
		this.paint();
	}
	,paint: function() {
		if(this.game.isFinished && this.game.turns == 0) {
			return;
		}
		if(Game.debugTime) {
			this.game.timerTime = window.performance.now();
		}
		if(UI.modernMode && this.firstTime) {
			this.loadTextImages();
			this.firstTime = false;
		}
		var ctx = this.map.getContext("2d",null);
		if(UI.modernMode) {
			var w = 0.0;
			var h = 0.0;
			if(this.mapWidth < this.mapHeight) {
				w = this.mapWidth;
				h = this.bgImage.height / (this.bgImage.width / this.mapWidth);
				if(h < this.mapHeight) {
					w = this.bgImage.width / (this.bgImage.height / this.mapHeight);
					h = this.mapHeight + 1;
				}
			} else {
				w = this.bgImage.width / (this.bgImage.height / this.mapHeight);
				h = this.mapHeight + 1;
				if(w < this.mapWidth) {
					w = this.mapWidth;
					h = this.bgImage.height / (this.bgImage.width / this.mapWidth);
				}
			}
			ctx.drawImage(this.bgImage,0,0,w,h);
		} else {
			ctx.fillStyle = "black";
			ctx.fillRect(0,0,this.mapWidth,this.mapHeight);
			ctx.font = "14px Verdana";
		}
		var _g_head = this.game.lines.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var l = val;
			l.paint(ctx,this.game.player.id);
		}
		var _g1 = 0;
		var _g2 = this.game.nodes;
		while(_g1 < _g2.length) {
			var n = _g2[_g1];
			++_g1;
			n.uiNode.paint(ctx);
		}
		if(this.game.player.options.getBool("mapAdvancedMode")) {
			var fontSize = this.zoom * Std.parseInt(window.getComputedStyle(window.document.documentElement).getPropertyValue("--advanced-mode-font-size")) | 0;
			ctx.font = fontSize + "px " + window.getComputedStyle(window.document.documentElement).getPropertyValue("--advanced-mode-font");
			var _g3 = 0;
			var _g4 = this.game.nodes;
			while(_g3 < _g4.length) {
				var n1 = _g4[_g3];
				++_g3;
				n1.uiNode.paintAdvanced(ctx);
			}
		}
		if(this.game.difficulty.mapWidth > this.mapWidth || this.game.difficulty.mapHeight > this.mapHeight) {
			this.updateMinimap();
			ctx.drawImage(this.minimap,this.mapWidth - this.minimap.width,this.mapHeight - this.minimap.height);
		}
		var _this = this.game;
		if(Game.debugTime) {
			console.log("Game.hx:583:","map paint" + ": " + (window.performance.now() - _this.timerTime) + "ms");
		}
	}
	,updateMinimap: function() {
		var ctx = this.minimap.getContext("2d",null);
		ctx.clearRect(0,0,this.minimap.width,this.minimap.height);
		var xscale = 1.0 * this.game.difficulty.mapWidth / this.minimap.width;
		var yscale = 1.0 * this.game.difficulty.mapHeight / this.minimap.height;
		ctx.fillStyle = "rgba(20,20,20,0.65)";
		ctx.fillRect(0,0,this.minimap.width,this.minimap.height);
		var imageData = ctx.getImageData(0,0,this.minimap.width,this.minimap.height);
		var pix = imageData.data;
		var x = 0;
		var y = 0;
		var index = 0;
		var color = null;
		var _g = 0;
		var _g1 = this.game.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			if(n.visibility[this.game.player.id]) {
				x = n.x / xscale | 0;
				y = n.y / yscale | 0;
				color = UI.vars.nodeNeutralPixelColors;
				if(n.owner != null) {
					color = UI.vars.nodePixelColors[n.owner.id];
				}
				index = (x + y * this.minimap.width) * 4;
				pix[index] = color[0];
				pix[index + 1] = color[1];
				pix[index + 2] = color[2];
				pix[index + 4] = color[0];
				pix[index + 5] = color[1];
				pix[index + 6] = color[2];
				index = (x + (y + 1) * this.minimap.width) * 4;
				pix[index] = color[0];
				pix[index + 1] = color[1];
				pix[index + 2] = color[2];
				pix[index + 4] = color[0];
				pix[index + 5] = color[1];
				pix[index + 6] = color[2];
			}
		}
		ctx.putImageData(imageData,0,0);
		ctx.strokeStyle = UI.classicMode ? "rgb(100,100,100)" : "rgb(200,200,200)";
		ctx.lineWidth = 1.0;
		ctx.strokeRect(this.viewRect.x / xscale + 1,this.viewRect.y / yscale + 1,this.mapWidth / xscale / this.zoom - 1,this.mapHeight / yscale / this.zoom - 1);
	}
	,paintText: function(ctx,syms,row,x,y) {
		var i = 0;
		var _g = 0;
		while(_g < syms.length) {
			var ch = syms[_g];
			++_g;
			ctx.drawImage(this.fontImage,ch * 5,row * 8,5,8,x + i * 6,y,5,8);
			++i;
		}
	}
	,hideTooltip: function() {
		this.tooltip.style.display = "none";
	}
	,onWheel: function(event) {
		if(this.game.difficulty.mapWidth < this.game.difficulty.mapHeight) {
			this.minZoom = 1.0 * this.viewRect.w / this.game.difficulty.mapWidth;
		} else {
			this.minZoom = 1.0 * this.viewRect.h / this.game.difficulty.mapHeight;
		}
		if(this.minZoom > 1.0) {
			this.minZoom = 1.0;
		}
		var cx = this.viewRect.w / 2 / this.zoom + this.viewRect.x | 0;
		var cy = this.viewRect.h / 2 / this.zoom + this.viewRect.y | 0;
		var d = 0;
		if(event != null) {
			d = event.deltaY < 0 ? 1 : -1;
		}
		var oldzoom = this.zoom;
		this.zoom += 0.05 * d;
		if(this.zoom < this.minZoom) {
			this.zoom = this.minZoom;
		}
		if(this.zoom > 1.0) {
			this.zoom = 1.0;
		}
		if(this.zoom == oldzoom) {
			return;
		}
		this.center(cx,cy);
	}
	,onMouseMove: function(event) {
		if(event.buttons == 0) {
			this.isDrag = false;
		}
		if(event.buttons > 0) {
			window.getSelection().empty();
		}
		if(this.isDrag) {
			this.map.style.cursor = "grabbing";
			this.viewRect.x -= (event.clientX - this.dragEventX) / this.zoom | 0;
			this.viewRect.y -= (event.clientY - this.dragEventY) / this.zoom | 0;
			this.dragEventX = event.clientX;
			this.dragEventY = event.clientY;
			this.rectBounds();
			this.paint();
			return;
		}
		var node = this.getEventNode(event);
		if(node == null) {
			this.map.style.cursor = "grab";
			this.tooltip.style.display = "none";
			return;
		}
		this.map.style.cursor = "pointer";
		if(this.game.player.options.getBool("mapAdvancedMode")) {
			return;
		}
		var text = node.uiNode.getTooltip();
		var cnt = 0;
		var ii = 0;
		while(true) {
			var i = text.indexOf("<br>",ii);
			if(i == -1) {
				break;
			}
			ii = i + 1;
			++cnt;
		}
		var mapRect = this.map.getBoundingClientRect();
		var x = event.clientX - mapRect.x + 10;
		var y = event.clientY - mapRect.y + 10;
		if(x + 250 > window.innerWidth) {
			x = window.innerWidth - 250;
		}
		if(y + cnt * 20 + 50 > window.innerHeight) {
			y = window.innerHeight - cnt * 20 - 50;
		}
		this.tooltip.innerHTML = text;
		this.tooltip.style.left = x + "px";
		this.tooltip.style.top = y + "px";
		this.tooltip.style.width = null;
		this.tooltip.style.height = null;
		this.tooltip.style.display = "inline";
	}
	,onMouseDown: function(event) {
		if(this.viewRect.w >= this.game.difficulty.mapWidth && this.viewRect.h >= this.game.difficulty.mapHeight) {
			return;
		}
		if(this.getEventNode(event) != null) {
			return;
		}
		this.isDrag = true;
		this.dragEventX = event.clientX;
		this.dragEventY = event.clientY;
		this.map.style.cursor = "grabbing";
	}
	,onMouseUp: function(event) {
		this.isDrag = false;
		this.map.style.cursor = "grab";
	}
	,onMouseOut: function(event) {
		this.tooltip.style.display = "none";
	}
	,onClick: function(event) {
		if(this.game.isFinished) {
			return;
		}
		var node = this.getEventNode(event);
		if(node == null) {
			return;
		}
		if(this.game.isTutorial && this.game.turns == 0) {
			return;
		}
		var ret = this.game.player.activate(node);
		if(ret == "ok") {
			this.game.tutorial.play("gainNode");
			if(this.game.player.origin.isProtected) {
				this.game.tutorial.play("originProtected");
			}
			if(this.game.player.awareness >= 10) {
				this.game.tutorial.play("awareness");
			}
		}
		this.paint();
	}
	,rectBounds: function() {
		if(this.viewRect.x * this.zoom + this.viewRect.w > this.game.difficulty.mapWidth * this.zoom) {
			this.viewRect.x = (this.game.difficulty.mapWidth * this.zoom - this.viewRect.w) / this.zoom | 0;
		}
		if(this.viewRect.y * this.zoom + this.viewRect.h > this.game.difficulty.mapHeight * this.zoom) {
			this.viewRect.y = (this.game.difficulty.mapHeight * this.zoom - this.viewRect.h) / this.zoom | 0;
		}
		if(this.viewRect.x < 0) {
			this.viewRect.x = 0;
		}
		if(this.viewRect.y < 0) {
			this.viewRect.y = 0;
		}
	}
	,center: function(x,y) {
		this.viewRect.x = (x * this.zoom - this.viewRect.w / 2) / this.zoom | 0;
		this.viewRect.y = (y * this.zoom - this.viewRect.h / 2) / this.zoom | 0;
		this.rectBounds();
		this.paint();
	}
	,getEventNode: function(event) {
		if(this.game.nodes == null) {
			return null;
		}
		var mapRect = this.map.getBoundingClientRect();
		var x = (event.clientX - mapRect.x) / this.zoom + this.viewRect.x;
		var y = (event.clientY - mapRect.y) / this.zoom + this.viewRect.y;
		var node = null;
		var r = UI.classicMode ? 10 : 32;
		var _g = 0;
		var _g1 = this.game.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			if(!n.visibility[this.game.player.id]) {
				continue;
			}
			if(x >= n.x && x <= n.x + 2 * r && y >= n.y && y <= n.y + 2 * r) {
				node = n;
				break;
			}
		}
		return node;
	}
	,clear: function() {
	}
	,resize: function() {
		var bw = Std.parseInt(this.map.style.borderWidth);
		var panelRect = this.mapBorder.getBoundingClientRect();
		var marginx = Std.parseInt(window.getComputedStyle(window.document.documentElement).getPropertyValue("--map-margin-x"));
		var marginy = Std.parseInt(window.getComputedStyle(window.document.documentElement).getPropertyValue("--map-margin-y"));
		this.mapWidth = panelRect.width - marginx;
		this.mapHeight = panelRect.height - marginy;
		this.map.width = this.mapWidth | 0;
		this.map.height = this.mapHeight | 0;
		this.map.style.width = this.mapWidth + "px";
		this.map.style.height = this.mapHeight + "px";
		this.viewRect.w = this.map.width;
		this.viewRect.h = this.map.height;
		if(this.game.isNeverStarted) {
			return;
		}
		if(this.game.difficulty.mapWidth <= this.mapWidth && this.game.difficulty.mapHeight <= this.mapHeight) {
			this.viewRect.x = 0;
			this.viewRect.y = 0;
		}
		this.onWheel(null);
		this.paint();
	}
};
Math.__name__ = true;
var Message = function(uivar,gvar) {
	this.ui = uivar;
	this.game = gvar;
	this.isVisible = false;
	this.timer = null;
};
Message.__name__ = true;
Message.prototype = {
	onClose: function(event) {
		window.document.body.removeChild(this.text);
		this.isVisible = false;
	}
	,runTimer: function() {
		this.onClose(null);
	}
	,show: function(s) {
		if(this.isVisible) {
			this.onClose(null);
		}
		if(this.timer != null) {
			window.clearTimeout(this.timer);
		}
		this.timer = window.setTimeout($bind(this,this.runTimer),1500);
		var w = 11 * (s.length + 4) + 40;
		this.text = window.document.createElement("div");
		this.text.className = "messageText";
		this.text.innerHTML = s;
		window.document.body.appendChild(this.text);
		this.text.style.display = "inline";
		this.isVisible = true;
	}
};
var MultiplayerMenu = function(uivar,gvar) {
	Window.call(this,uivar,gvar,"multiMenu",450,236,20,493);
	Tools.label({ id : "titleLabel", text : "Multiplayer game parameters", w : 350, h : 30, x : 50, y : 5, container : this.window});
	var divel = window.document.createElement("div");
	divel.className = "uiText";
	divel.style.top = "12.5%";
	divel.style.width = "95.6%";
	divel.style.height = "67%";
	this.window.appendChild(divel);
	this.difElements = new haxe_ds_List();
	var y = 10;
	var _g = 0;
	var _g1 = MultiplayerMenu.difElementInfo;
	while(_g < _g1.length) {
		var info = _g1[_g];
		++_g;
		Tools.label({ id : "label" + info.name, text : info.title, w : 300, h : 20, x : 10, y : y, fontSize : 14, container : divel});
		var el = null;
		if(info.type == "bool") {
			el = Tools.checkbox({ id : "multi_" + info.name, text : "" + Std.string(Reflect.field(Static.difficulty[2],info.name)), w : 100, h : null, x : 310, y : y, fontSize : 14, container : divel});
		} else if(info.type == "select") {
			el = window.document.createElement("select");
			el.id = "multi_" + info.name;
			el.className = "selectOption";
			el.style.width = "100px";
			el.style.left = "310px";
			el.style.top = "" + y;
			el.style.fontSize = "14px";
			el.style.position = "absolute";
			var s = "<select class=selectOption onchange='Game.instance.ui.mpMenu.onSelect(this.value)'>";
			var list = info.params;
			var _g2 = 0;
			while(_g2 < list.length) {
				var item = list[_g2];
				++_g2;
				s += "<option class=selectOption>" + item;
			}
			s += "</select>";
			el.innerHTML = s;
			divel.appendChild(el);
		} else {
			el = Tools.textfield({ id : "multi_" + info.name, text : "" + Std.string(Reflect.field(Static.difficulty[2],info.name)), w : 100, h : null, x : 310, y : y, fontSize : 14, container : divel});
		}
		y += 30;
		this.difElements.add(el);
	}
	var b = Tools.button({ id : "startMultiplayerGame", text : "Start", w : 80, h : null, x : null, y : null, container : this.window, func : $bind(this,this.onStartGame)});
	b.style.left = "33%";
	b.style.bottom = "3%";
	b.style.transform = "translate(-50%)";
	this.close.style.left = "66%";
	this.close.style.bottom = "3%";
	this.close.style.transform = "translate(-50%)";
};
MultiplayerMenu.__name__ = true;
MultiplayerMenu.__super__ = Window;
MultiplayerMenu.prototype = $extend(Window.prototype,{
	getInfoValue: function(info) {
		var el = null;
		var _g_head = this.difElements.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			if(e.id == "multi_" + info.name) {
				el = e;
				break;
			}
		}
		var value = null;
		if(info.type == "int") {
			value = Std.parseInt(el.value);
		} else if(info.type == "float") {
			value = parseFloat(el.value);
		} else if(info.type == "select") {
			var list = info.params;
			var id = -1;
			var _g1 = 0;
			var _g2 = list.length;
			while(_g1 < _g2) {
				var i = _g1++;
				if(list[i] == el.value) {
					value = i;
					break;
				}
			}
		} else if(info.type == "bool") {
			value = el.checked;
		}
		return value;
	}
	,onStartGame: function(e) {
		var dif = { level : -1};
		var level = this.getInfoValue(MultiplayerMenu.difElementInfo[2]);
		var _g = 0;
		var _g1 = Reflect.fields(Static.difficulty[level]);
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			dif[f] = Reflect.field(Static.difficulty[level],f);
		}
		var _g2 = 0;
		var _g3 = MultiplayerMenu.difElementInfo;
		while(_g2 < _g3.length) {
			var info = _g3[_g2];
			++_g2;
			var value = this.getInfoValue(info);
			if(info.name == "numCults") {
				dif.numCults = value;
			} else if(info.name == "numPlayers") {
				dif.numPlayers = value;
			} else if(info.name == "mapSize") {
				if(value == 0) {
					dif.mapWidth = 780;
					dif.mapHeight = 580;
					dif.nodesCount = 100;
				} else if(value == 1) {
					dif.mapWidth = 1170;
					dif.mapHeight = 870;
					dif.nodesCount = 225;
				} else if(value == 2) {
					dif.mapWidth = 1560;
					dif.mapHeight = 1160;
					dif.nodesCount = 400;
				} else if(value == 3) {
					dif.mapWidth = 3120;
					dif.mapHeight = 2320;
					dif.nodesCount = 1600;
				}
			}
		}
		if(dif.numPlayers < 2) {
			dif.numPlayers = 2;
		}
		if(dif.numCults < 2) {
			dif.numCults = 2;
		}
		if(dif.numPlayers > 8) {
			dif.numPlayers = 8;
		}
		if(dif.numCults > 8) {
			dif.numCults = 8;
		}
		this.game.restart(-1,dif);
		this.onClose(null);
		this.ui.mainMenu.onClose(null);
	}
	,onKey: function(e) {
		if(e.keyCode == 27) {
			this.onClose(null);
		}
	}
	,onCloseHook: function() {
		this.ui.mainMenu.show();
	}
});
var Music = function(ui) {
	this.ui = ui;
	this.volume = 100;
	var _this = ui.config;
	var v = getCookie("musicVolume");
	if(v != null) {
		this.volume = Std.parseInt(v);
	}
	this.isInited = false;
	this.trackID = -1;
	this.playlist = [["Introspective","Occlusion","Fluid Dynamics","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi051a_intro-fluid_dynamics.ogg","http://www.kahvi.org/releases.php?release_number=051"],["Introspective","Occlusion","Contain Release","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi051b_intro-contain_release.ogg","http://www.kahvi.org/releases.php?release_number=051"],["Introspective","Occlusion","Wave Propagation","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi051c_intro-wave_propagation.ogg","http://www.kahvi.org/releases.php?release_number=051"],["Introspective","Analogy","Mail Order Monsters","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi080a_intro-mail_order_monsters.ogg","http://www.kahvi.org/releases.php?release_number=080"],["Introspective","Analogy","Cartographer","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi080b_intro-cartographer.ogg","http://www.kahvi.org/releases.php?release_number=080"],["Introspective","Analogy","Gone Awry","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi080c_intro-analogy_gone_awry.ogg","http://www.kahvi.org/releases.php?release_number=080"],["Introspective","Analogy","Bearing Your Name","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi080d_intro-bearing_your_name.ogg","http://www.kahvi.org/releases.php?release_number=080"],["Introspective","Crossing Borders","Crossing Borders","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi094a_introspective-crossing_borders.ogg","http://www.kahvi.org/releases.php?release_number=094"],["Introspective","Crossing Borders","Medina Of Tunis","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi094b_introspective-medina_of_tunis.ogg","http://www.kahvi.org/releases.php?release_number=094"],["Introspective","Black Mesa Winds","Crepuscular Activity","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi236a_introspective-crepuscular_activity.ogg","http://www.kahvi.org/releases.php?release_number=236"],["Introspective","Black Mesa Winds","Vanishing Point","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi236b_introspective-vanishing_point.ogg","http://www.kahvi.org/releases.php?release_number=236"],["Introspective","Black Mesa Winds","Black Mesa Winds","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi236c_introspective-black_mesa_winds.ogg","http://www.kahvi.org/releases.php?release_number=236"],["Introspective","Black Mesa Winds","Convection","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi236d_introspective-convection.ogg","http://www.kahvi.org/releases.php?release_number=236"],["Introspective","Black Mesa Winds","Sky City","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi236e_introspective-sky_city.ogg","http://www.kahvi.org/releases.php?release_number=236"],["Introspective","Black Mesa Winds","Predator Distribution","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi236f_introspective-predator_distribution.ogg","http://www.kahvi.org/releases.php?release_number=236"],["Introspective","Black Mesa Winds","Fahrenheit","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi236g_introspective-fahrenheit.ogg","http://www.kahvi.org/releases.php?release_number=236"],["Introspective","Black Mesa Winds","Riverside","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi236h_introspective-riverside.ogg","http://www.kahvi.org/releases.php?release_number=236"],["Introspective","Black Mesa Winds","Xerophytes","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi236i_introspective-xerophytes.ogg","http://www.kahvi.org/releases.php?release_number=236"],["Introspective","Black Mesa Winds","Differential Erosion","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi236j_introspective-differential_erosion.ogg","http://www.kahvi.org/releases.php?release_number=236"],["Introspective","Black Mesa Winds","Overwhelming Sky","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi236k_introspective-overwhelming_sky.ogg","http://www.kahvi.org/releases.php?release_number=236"],["Curious Inversions","Whom","Antibiotic Resistance","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi254a_curious_inversions-antibiotic_resistance.ogg","http://www.kahvi.org/releases.php?release_number=254"],["Curious Inversions","Whom","Antiquity","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi254b_curious_inversions-antiquity.ogg","http://www.kahvi.org/releases.php?release_number=254"],["Curious Inversions","Whom","Geonosian Advance","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi254c_curious_inversions-geonosian_advance.ogg","http://www.kahvi.org/releases.php?release_number=254"],["Curious Inversions","Whom","In The Scholar's Wake","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi254d_curious_inversions-in_the_scholars_wake.ogg","http://www.kahvi.org/releases.php?release_number=254"],["Curious Inversions","Whom","Predators","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi254e_curious_inversions-predators.ogg","http://www.kahvi.org/releases.php?release_number=254"],["Curious Inversions","Whom","Sissot Eclipse","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi254f_curious_inversions-sissots_eclipse.ogg","http://www.kahvi.org/releases.php?release_number=254"],["Curious Inversions","Whom","Voluntary","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi254g_curious_inversions-voluntary.ogg","http://www.kahvi.org/releases.php?release_number=254"],["Curious Inversions","Whom","Windslak","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi254h_curious_inversions-windslak.ogg","http://www.kahvi.org/releases.php?release_number=254"],["Introspective","Gewesen","Gewesen","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi176a_introspective-gewesen.ogg","http://www.kahvi.org/releases.php?release_number=176"],["Introspective","Gewesen","Undocumented","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi176b_introspective-undocumented.ogg","http://www.kahvi.org/releases.php?release_number=176"],["Introspective","Gewesen","Gewesen pt2","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi176c_introspective-gewesen_part2.ogg","http://www.kahvi.org/releases.php?release_number=176"],["Introspective","Gewesen","Specular Highlights","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi176d_introspective-specular_highlights.ogg","http://www.kahvi.org/releases.php?release_number=176"],["Introspective","Gewesen","The Leaves In The Rain","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi176e_introspective-the_leaves_in_the_rain.ogg","http://www.kahvi.org/releases.php?release_number=176"],["Curious Inversions","Schoolyard Crows","Unfamiliar Domain","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi353a_curious_inversions-unfamiliar_domain.ogg","http://www.kahvi.org/releases.php?release_number=353"],["Curious Inversions","Schoolyard Crows","Restrictions","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi353b_curious_inversions-restrictions.ogg","http://www.kahvi.org/releases.php?release_number=353"],["Curious Inversions","Schoolyard Crows","Inefficient Sacrifice","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi353c_curious_inversions-inefficient_sacrifice.ogg","http://www.kahvi.org/releases.php?release_number=353"],["Curious Inversions","Schoolyard Crows","Elder Grove","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi353d_curious_inversions-elder_grove.ogg","http://www.kahvi.org/releases.php?release_number=353"],["Curious Inversions","Schoolyard Crows","Woven Hand","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi353e_curious_inversions-woven_hand.ogg","http://www.kahvi.org/releases.php?release_number=353"],["Curious Inversions","Schoolyard Crows","Eccentric Structures","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi353f_curious_inversions-eccentric_structures.ogg","http://www.kahvi.org/releases.php?release_number=353"],["Curious Inversions","Schoolyard Crows","Fetter","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi353g_curious_inversions-fetter.ogg","http://www.kahvi.org/releases.php?release_number=353"],["Curious Inversions","Schoolyard Crows","Unit 731","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi353h_curious_inversions-unit_731.ogg","http://www.kahvi.org/releases.php?release_number=353"],["Curious Inversions","Schoolyard Crows","Symmetric Immortality","http://ftp.scene.org/pub/music/groups/kahvicollective/kahvi353i_curious_inversions-symmetric_immortality.ogg","http://www.kahvi.org/releases.php?release_number=353"]];
};
Music.__name__ = true;
Music.prototype = {
	random: function() {
		SoundManager.destroySound("music");
		while(true) {
			var t = Math.random() * (this.playlist.length - 1) | 0;
			if(t != this.trackID) {
				this.trackID = t;
				break;
			}
		}
		SoundManager.createSound({ id : "music", url : this.playlist[this.trackID][3], volume : this.volume});
		SoundManager.play("music",{ onfinish : $bind(this,this.random)});
		this.onRandom();
	}
	,onRandom: function() {
	}
	,start: function() {
		var _this = this.ui.config;
		var val = getCookie("music");
		if(val == null || val == "0") {
			return;
		}
		this.play();
	}
	,increaseVolume: function() {
		var v = this.volume;
		v += 10;
		if(v > 100) {
			v = 100;
		}
		if(v == this.volume) {
			return;
		}
		this.volume = v;
		var _this = this.ui.config;
		var val = "" + this.volume;
		setCookie("musicVolume",val,new Date(2015, 0, 0, 0, 0, 0, 0));
		SoundManager.setVolume(this.volume);
	}
	,decreaseVolume: function() {
		var v = this.volume;
		v -= 10;
		if(v < 0) {
			v = 0;
		}
		if(v == this.volume) {
			return;
		}
		this.volume = v;
		var _this = this.ui.config;
		var val = "" + this.volume;
		setCookie("musicVolume",val,new Date(2015, 0, 0, 0, 0, 0, 0));
		SoundManager.setVolume(this.volume);
	}
	,play: function() {
		SoundManager.stopAll();
		if(this.trackID == -1) {
			this.random();
		} else {
			SoundManager.play("music",{ onfinish : $bind(this,this.random)});
		}
		var _this = this.ui.config;
		setCookie("music","1",new Date(2015, 0, 0, 0, 0, 0, 0));
	}
	,stop: function() {
		SoundManager.stopAll();
		var _this = this.ui.config;
		setCookie("music","0",new Date(2015, 0, 0, 0, 0, 0, 0));
	}
	,pause: function() {
		SoundManager.togglePause("music");
	}
	,getName: function() {
		var a = this.playlist[this.trackID];
		return "<span style='color: #080'>Track:</span> " + a[2] + "<br><span style='color: #080'>Album:</span> " + a[1] + "<br><span style='color: #080'>Artist:</span> " + a[0];
	}
	,getPage: function() {
		return this.playlist[this.trackID][4];
	}
};
var Node = function(gvar,uivar,newx,newy,index) {
	this.game = gvar;
	this.ui = uivar;
	this.id = index;
	this.lines = new haxe_ds_List();
	this.links = new haxe_ds_List();
	this.visibility = [];
	var _g = 0;
	var _g1 = this.game.difficulty.numCults;
	while(_g < _g1) {
		var i = _g++;
		this.visibility.push(false);
	}
	this.isKnown = [];
	var _g2 = 0;
	var _g3 = this.game.difficulty.numCults;
	while(_g2 < _g3) {
		var i1 = _g2++;
		this.isKnown.push(false);
	}
	this.owner = null;
	this.x = newx;
	this.y = newy;
	this.centerX = this.x + Math.round(UI.vars.markerWidth / 2);
	this.centerY = this.y + Math.round(UI.vars.markerHeight / 2);
	this.generateAttributes();
	this.uiNode = new UINode(this.game,this.ui,this);
};
Node.__name__ = true;
Node.prototype = {
	generateAttributes: function() {
		this.gender = Std.random(2) == 0 ? false : true;
		this.name = GenName.generate(this.gender);
		this.jobID = Std.random(Node.jobs.length);
		this.imageID = this.jobID * 2 + (this.gender ? 1 : 0);
		this.job = Node.jobs[this.jobID];
		this.isGenerator = false;
		this.isTempGenerator = false;
		this.isKnown = [];
		var _g = 0;
		var _g1 = this.game.difficulty.numCults;
		while(_g < _g1) {
			var i = _g++;
			this.isKnown.push(false);
		}
		this.power = [0,0,0];
		this.powerGenerated = [0,0,0];
		this.level = 0;
		var index = Math.round((Game.numPowers - 1) * Math.random());
		this.power[index] = 1;
	}
	,makeGenerator: function() {
		var powerIndex = 0;
		var _g = 0;
		var _g1 = Game.numPowers;
		while(_g < _g1) {
			var ii = _g++;
			if(this.power[ii] > 0) {
				this.power[ii]++;
				powerIndex = ii;
			}
		}
		var ii1 = -1;
		while(true) {
			ii1 = Math.round((Game.numPowers - 1) * Math.random());
			if(ii1 != powerIndex) {
				break;
			}
		}
		this.powerGenerated[ii1] = 1;
		this.setGenerator(true);
	}
	,load: function(n) {
		this.power = n.p;
		if(n.l != null) {
			this.level = n.l;
		}
		if(n.vis != null) {
			var vis = n.vis;
			this.visibility = [];
			var i = 0;
			var _g = 0;
			while(_g < vis.length) {
				var v = vis[_g];
				++_g;
				this.visibility.push(v == 1);
				if(v == 1) {
					this.uiNode.setVisible(this.game.cults[i],true);
				}
				++i;
			}
		}
		if(n.o != null) {
			this.owner = this.game.cults[n.o];
			this.owner.nodes.add(this);
		}
		if(n.pg != null) {
			this.isGenerator = true;
			this.powerGenerated = n.pg;
			if(this.owner != null) {
				var _g1 = 0;
				var _g11 = Game.numPowers;
				while(_g1 < _g11) {
					var i1 = _g1++;
					this.owner.powerMod[i1] += Math.round(this.powerGenerated[i1]);
				}
			}
		}
	}
	,save: function() {
		var obj = { id : this.id, p : this.power, x : this.x, y : this.y};
		if(this.owner != null) {
			obj.o = this.owner.id;
		}
		if(this.level > 0) {
			obj.l = this.level;
		}
		var vis = [];
		var savevis = false;
		var _g = 0;
		var _g1 = this.visibility;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			vis.push(v ? 1 : 0);
			if(v) {
				savevis = true;
			}
		}
		if(savevis) {
			obj.vis = vis;
		}
		if(this.isGenerator) {
			obj.pg = this.powerGenerated;
		}
		return obj;
	}
	,update: function() {
		this.isProtected = false;
		if(this.isGenerator && this.owner != null) {
			var cnt = 0;
			var _g_head = this.links.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var n = val;
				if(n.owner == this.owner) {
					++cnt;
				}
			}
			if(cnt >= 3) {
				this.isProtected = true;
			}
		}
	}
	,distance: function(node) {
		return Math.sqrt((node.x - this.x) * (node.x - this.x) + (node.y - this.y) * (node.y - this.y));
	}
	,distanceXY: function(xx,yy) {
		return Math.sqrt((xx - this.x) * (xx - this.x) + (yy - this.y) * (yy - this.y));
	}
	,setGenerator: function(isgen) {
		this.isGenerator = isgen;
		this.update();
	}
	,setOwner: function(c) {
		var prevOwner = this.owner;
		if(this.isGenerator) {
			var _g = 0;
			var _g1 = Game.numPowers;
			while(_g < _g1) {
				var i = _g++;
				c.powerMod[i] += Math.round(this.powerGenerated[i]);
			}
		}
		this.clearLines();
		if(this.owner == null) {
			var _g2 = 0;
			var _g11 = Game.numPowers;
			while(_g2 < _g11) {
				var i1 = _g2++;
				if(this.power[i1] > 0) {
					this.power[i1]++;
				}
			}
		}
		if(this.owner != null) {
			this.owner.nodes.remove(this);
		}
		this.owner = c;
		this.isKnown[this.owner.id] = true;
		this.owner.nodes.add(this);
		this.update();
		this.showLinks();
		if(prevOwner != null) {
			this.updateLinkVisibility(prevOwner);
		}
		if(this.isGenerator) {
			var _g3 = this.owner;
			_g3.set_awareness(_g3.awareness + 2);
		} else {
			var _g4 = this.owner;
			_g4.set_awareness(_g4.awareness + 1);
		}
		if(!this.owner.isAI) {
			this.ui.status.update();
		}
		this.paintLines();
		var _g_head = this.links.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var n = val;
			n.update();
		}
		if(prevOwner != null) {
			prevOwner.loseNode(this,this.owner);
		}
		if(this.visibility[this.game.player.id] && !this.owner.isDiscovered[this.game.player.id]) {
			this.game.player.discover(this.owner);
		}
	}
	,removeOwner: function() {
		if(this.owner == null) {
			return;
		}
		var prevOwner = this.owner;
		this.clearLines();
		this.owner.nodes.remove(this);
		this.owner = null;
		this.level = 0;
		this.update();
		this.updateLinkVisibility(prevOwner);
		var _g_head = this.links.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var n = val;
			n.update();
		}
		var _g1 = 0;
		var _g2 = Game.numPowers;
		while(_g1 < _g2) {
			var i = _g1++;
			if(this.power[i] > 2) {
				this.power[i] = 2;
			}
		}
		if(prevOwner != null) {
			prevOwner.loseNode(this);
		}
	}
	,setVisible: function(cult,v) {
		this.visibility[cult.id] = v;
		this.uiNode.setVisible(cult,v);
		if(!cult.isAI) {
			if(Game.mapVisible) {
				v = true;
			}
			var _g_head = this.lines.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var l = val;
				l.visibility[cult.id] = v;
			}
			if(this.owner != null && !this.owner.isDiscovered[cult.id]) {
				cult.discover(this.owner);
			}
		}
	}
	,isVisible: function(c) {
		return this.visibility[c.id];
	}
	,upgrade: function() {
		if(this.level >= Game.followerNames.length - 1) {
			return;
		}
		var _g = 0;
		var _g1 = Game.numPowers;
		while(_g < _g1) {
			var i = _g++;
			if(this.power[i] > 0) {
				this.power[i]++;
			}
		}
		this.level++;
	}
	,updateLinkVisibility: function(cult) {
		var _g_head = this.links.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var n = val;
			if(n.visibility[cult.id] && n.owner != cult) {
				var vis = false;
				var _g_head1 = n.links.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var n2 = val1;
					if(n2.owner == cult) {
						vis = true;
						break;
					}
				}
				n.setVisible(cult,vis);
			}
		}
		var hasLinks = false;
		var _g1_head = this.links.h;
		while(_g1_head != null) {
			var val2 = _g1_head.item;
			_g1_head = _g1_head.next;
			var n21 = val2;
			if(n21.owner == cult) {
				this.setVisible(cult,true);
				hasLinks = true;
				break;
			}
		}
		if(!hasLinks) {
			this.setVisible(cult,false);
		}
	}
	,paintLines: function() {
		var hasLine = false;
		var _g_head = this.links.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var n = val;
			if(n.owner == this.owner) {
				var l = Line.create(this.ui,this.owner,n,this);
				this.game.lines.add(l);
				n.lines.add(l);
				this.lines.add(l);
				var _g = 0;
				var _g1 = this.game.cults;
				while(_g < _g1.length) {
					var c = _g1[_g];
					++_g;
					if(n.visibility[c.id] || this.visibility[c.id]) {
						l.visibility[c.id] = true;
					}
				}
				hasLine = true;
			}
		}
		if(hasLine) {
			return;
		}
		var dist = 10000;
		var nc = null;
		var _g1_head = this.owner.nodes.h;
		while(_g1_head != null) {
			var val1 = _g1_head.item;
			_g1_head = _g1_head.next;
			var n1 = val1;
			if(this != n1 && this.distance(n1) < dist) {
				dist = this.distance(n1);
				nc = n1;
			}
		}
		var l1 = Line.create(this.ui,this.owner,nc,this);
		this.game.lines.add(l1);
		nc.lines.add(l1);
		this.lines.add(l1);
		var _g2 = 0;
		var _g3 = this.game.cults;
		while(_g2 < _g3.length) {
			var c1 = _g3[_g2];
			++_g2;
			if(nc.visibility[c1.id] || this.visibility[c1.id]) {
				l1.visibility[c1.id] = true;
			}
		}
	}
	,showLinks: function() {
		var _g_head = this.links.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var n = val;
			n.setVisible(this.owner,true);
		}
	}
	,clearLines: function() {
		if(this.owner == null) {
			return;
		}
		var _g_head = this.lines.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var l = val;
			l.clear();
			this.game.lines.remove(l);
			l.startNode.lines.remove(l);
			l.endNode.lines.remove(l);
		}
	}
};
var Options = function(game,ui,c) {
	this.game = game;
	this.ui = ui;
	this.cult = c;
	this.list = new haxe_ds_StringMap();
};
Options.__name__ = true;
Options.prototype = {
	set: function(key,val) {
		if(val == false) {
			this.list.remove(key);
		} else {
			var _this = this.list;
			var value = val;
			if(__map_reserved[key] != null) {
				_this.setReserved(key,value);
			} else {
				_this.h[key] = value;
			}
		}
		if(this.game.difficulty.numPlayers == 1) {
			var _this1 = this.ui.config;
			var val1 = "" + Std.string(val);
			setCookie(key,val1,new Date(2015, 0, 0, 0, 0, 0, 0));
		}
	}
	,get: function(key) {
		var _this = this.list;
		if(__map_reserved[key] != null) {
			return _this.getReserved(key);
		} else {
			return _this.h[key];
		}
	}
	,getBool: function(key) {
		var _this = this.list;
		var ret = __map_reserved[key] != null ? _this.getReserved(key) : _this.h[key];
		if(ret == null) {
			return false;
		}
		return ret;
	}
};
var OptionsMenu = function(uivar,gvar) {
	Window.call(this,uivar,gvar,"options",800,536,20,493);
	this.contents = window.document.createElement("div");
	this.contents.className = "uiText";
	this.window.appendChild(this.contents);
};
OptionsMenu.__name__ = true;
OptionsMenu.__super__ = Window;
OptionsMenu.prototype = $extend(Window.prototype,{
	onShow: function() {
		this.contents.innerHTML = "";
		this.elements = new haxe_ds_List();
		var y = 10;
		var _g = 0;
		var _g1 = OptionsMenu.elementInfo;
		while(_g < _g1.length) {
			var info = _g1[_g];
			++_g;
			Tools.label({ id : "label" + info.name, text : info.title, w : 240, h : 20, x : 10, y : y, fontSize : 14, container : this.contents});
			var el = null;
			if(info.type == "bool") {
				el = Tools.checkbox({ id : info.name, text : "", w : 70, h : null, x : 240, y : y, fontSize : 14, container : this.contents});
				el.checked = this.game.player.options.getBool(info.name);
			} else {
				el = Tools.textfield({ id : info.name, text : "" + Std.string(this.game.player.options.get(info.name)), w : 70, h : 20, x : 240, y : y, fontSize : 14, container : this.contents});
			}
			Tools.label({ id : "note" + info.name, text : info.note, w : 450, h : 20, x : 310, y : info.y != null ? info.y : y, fontSize : 14, bold : false, container : this.contents});
			y += 30;
			this.elements.add(el);
		}
	}
	,onCloseHook: function() {
		var _g = 0;
		var _g1 = OptionsMenu.elementInfo;
		while(_g < _g1.length) {
			var info = _g1[_g];
			++_g;
			var el = null;
			var _g_head = this.elements.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var e = val;
				if(e.id == info.name) {
					el = e;
					break;
				}
			}
			var value = null;
			if(info.type == "int") {
				value = Std.parseInt(el.value);
			} else if(info.type == "float") {
				value = parseFloat(el.value);
			} else if(info.type == "bool") {
				value = el.checked;
			}
			this.game.player.options.set(info.name,value);
			if(this.game.difficulty.numPlayers == 1) {
				var _this = this.ui.config;
				var name = info.name;
				var val1 = "" + Std.string(value);
				setCookie(name,val1,new Date(2015, 0, 0, 0, 0, 0, 0));
			}
			if(info.name == "sectAdvisor" && !value) {
				var _g1_head = this.game.player.sects.h;
				while(_g1_head != null) {
					var val2 = _g1_head.item;
					_g1_head = _g1_head.next;
					var s = val2;
					s.taskImportant = false;
				}
			}
		}
		var fs = this.game.player.options.getBool("fullscreen");
		if(this.ui.fullscreen != fs) {
			this.ui.setFullscreen(fs);
		}
		this.game.applyPlayerOptions();
	}
	,onKey: function(e) {
		if(e.keyCode == 27) {
			this.onClose(null);
		}
	}
});
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
var SaveMenu = function(uivar,gvar) {
	this.ui = uivar;
	this.game = gvar;
	this.isVisible = false;
	this.window = Tools.window({ id : "saveMenuWindow", w : 420, h : 320, z : 25});
	Tools.label({ id : "saveLabel", text : "Key", w : 60, h : 30, x : 35, y : 30, container : this.window});
	var _this = this.ui.config;
	this.key = Tools.textfield({ id : "saveKey", text : getCookie("owner"), w : 205, h : 30, x : 85, y : 30, container : this.window});
	this.key.onclick = $bind(this,this.onKeyClick);
	Tools.button({ id : "saveRefresh", text : "Refresh", w : 100, h : 30, x : 300, y : 30, container : this.window, func : $bind(this,this.onRefresh)});
	this.noKey = Tools.label({ id : "loadLabel2", text : "Type in key to proceed.", w : 270, h : 30, x : 90, y : 150, container : this.window});
	this.saves = [];
	this.saveButtons = [];
	this.delButtons = [];
	var _g = 0;
	var _g1 = UI.maxSaves;
	while(_g < _g1) {
		var i = _g++;
		var b = Tools.button({ id : "save" + i, text : "...", w : 330, h : 30, x : 35, y : 70 + 40 * i, container : this.window, func : $bind(this,this.onSaveGame)});
		this.saveButtons.push(b);
		var b2 = Tools.button({ id : "del" + i, text : "X", w : 20, h : 30, x : 380, y : 70 + 40 * i, container : this.window, func : $bind(this,this.onDelGame)});
		this.delButtons.push(b2);
	}
	this.bg = Tools.bg();
	var container = this.window;
	var w = Std.parseInt(container.style.width);
	var b1 = Tools.button({ id : null, text : "Close", w : 80, h : null, x : null, y : null, container : container});
	b1.style.left = "50%";
	b1.style.bottom = "var(--close-button-bottom)";
	b1.style.transform = "translate(-50%)";
	this.close = b1;
	this.close.onclick = $bind(this,this.onClose);
};
SaveMenu.__name__ = true;
SaveMenu.prototype = {
	show: function() {
		var _g = 0;
		var _g1 = this.delButtons;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.style.display = "none";
		}
		var tmp;
		var _this = this.ui.config;
		if(getCookie("owner") != "") {
			var _this1 = this.ui.config;
			tmp = getCookie("owner") != null;
		} else {
			tmp = false;
		}
		if(tmp) {
			var req = new XMLHttpRequest();
			var _this2 = this.ui.config;
			req.open("GET","/save.list?owner=" + getCookie("owner"),false);
			req.send(null);
			var text = req.responseText;
			var list = JSON.parse(text);
			this.saves = list;
			var _g2 = 0;
			var _g3 = this.saveButtons;
			while(_g2 < _g3.length) {
				var b1 = _g3[_g2];
				++_g2;
				b1.style.display = "inline";
				b1.innerHTML = "---";
			}
			var i = 0;
			var _g4 = 0;
			while(_g4 < list.length) {
				var item = list[_g4];
				++_g4;
				var b2 = this.saveButtons[i];
				if(b2 == null) {
					break;
				}
				b2.innerHTML = item.name;
				this.delButtons[i].style.display = "inline";
				++i;
			}
			this.noKey.style.display = "none";
		} else {
			var _g21 = 0;
			var _g31 = this.saveButtons;
			while(_g21 < _g31.length) {
				var b3 = _g31[_g21];
				++_g21;
				b3.style.display = "none";
			}
			this.noKey.style.display = "inline";
		}
		var _this3 = this.ui.config;
		var tmp1 = getCookie("owner");
		this.key.value = tmp1;
		this.window.style.display = "inline";
		this.bg.style.display = "inline";
		this.close.style.display = "inline";
		this.isVisible = true;
		this.keyFocused = false;
	}
	,onKeyClick: function() {
		this.keyFocused = true;
	}
	,onRefresh: function(event) {
		var _this = this.ui.config;
		var val = this.key.value;
		setCookie("owner",val,new Date(2015, 0, 0, 0, 0, 0, 0));
		this.show();
	}
	,onSaveGame: function(event) {
		var b = Tools.getTarget(event);
		var n = Std.parseInt(b.id.substring(4));
		this.onSaveReal(n);
	}
	,onSaveReal: function(n) {
		var save = this.saves[n];
		var id = 0;
		if(save != null) {
			id = save.id;
		}
		var name = HxOverrides.dateStr(new Date());
		var req = new XMLHttpRequest();
		var _this = this.ui.config;
		req.open("POST","/save.save?owner=" + getCookie("owner") + "&id=" + id + "&name=" + name + "&version=" + Game.version,false);
		var obj = this.game.save();
		var str = JSON.stringify(obj);
		req.send(str);
		var text = req.responseText;
		if(text == "TooBig") {
			this.ui.alert("Save file too big (" + (str.length / 1024 | 0) + "kb)! Contact me to raise limit.");
			return;
		} else if(text == "TooManySaves") {
			this.ui.alert("Too many saved games already.");
			return;
		}
		this.onClose(null);
	}
	,onDelGame: function(event) {
		var b = Tools.getTarget(event);
		var n = Std.parseInt(b.id.substring(3));
		this.onDelReal(n);
	}
	,onDelReal: function(n) {
		var save = this.saves[n];
		var req = new XMLHttpRequest();
		var _this = this.ui.config;
		req.open("GET","/save.delete?owner=" + getCookie("owner") + "&id=" + save.id,false);
		req.send(null);
		var text = req.responseText;
		this.show();
	}
	,onKey: function(e) {
		if(this.keyFocused) {
			return;
		}
		if(e.keyCode == 49) {
			this.onSaveReal(0);
		} else if(e.keyCode == 50) {
			this.onSaveReal(1);
		} else if(e.keyCode == 51) {
			this.onSaveReal(2);
		} else if(e.keyCode == 52) {
			this.onSaveReal(3);
		} else if(e.keyCode == 53) {
			this.onSaveReal(4);
		} else if(e.keyCode == 27) {
			this.onClose(null);
		}
	}
	,onClose: function(event) {
		this.window.style.display = "none";
		this.bg.style.display = "none";
		this.close.style.display = "none";
		this.noKey.style.display = "none";
		var _g = 0;
		var _g1 = this.delButtons;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.style.display = "none";
		}
		var _g2 = 0;
		var _g3 = this.saveButtons;
		while(_g2 < _g3.length) {
			var b1 = _g3[_g2];
			++_g2;
			b1.style.display = "none";
		}
		this.isVisible = false;
	}
};
var SectsInfo = function(uivar,gvar) {
	Window.call(this,uivar,gvar,"sects",800,536,20,493);
	this.selectedNode = null;
	this.selectedNodeID = 0;
	var sectsBG = window.document.createElement("div");
	sectsBG.id = "sectsBGIMG";
	this.window.appendChild(sectsBG);
	var sectsFG = window.document.createElement("div");
	sectsFG.id = "sectsFG";
	sectsFG.className = "uiTextFG";
	sectsBG.appendChild(sectsFG);
	this.list = window.document.createElement("div");
	this.list.id = "sectsList";
	sectsFG.appendChild(this.list);
	this.text = window.document.createElement("div");
	this.text.className = "cultInfoLabel";
	this.window.appendChild(this.text);
	this.menu = Tools.window({ id : "sectsMenuWindow", fontSize : 16, w : 200, h : 280, z : 3000});
	this.menu.style.padding = "5px";
	this.menu.style.border = "1px solid";
	this.menu.style.opacity = "0.9";
};
SectsInfo.__name__ = true;
SectsInfo.e = function(s) {
	return window.document.getElementById(s);
};
SectsInfo.create = function(parent,s) {
	var el = window.document.createElement(s);
	parent.appendChild(el);
	return el;
};
SectsInfo.__super__ = Window;
SectsInfo.prototype = $extend(Window.prototype,{
	onKey: function(e) {
		if(e.keyCode == 27 || e.keyCode == 13 || e.keyCode == 32 || e.keyCode == 83) {
			this.onClose(null);
			return;
		}
	}
	,onSelect: function(strID) {
		var dotIndex = strID.indexOf(".");
		var dashIndex = strID.indexOf("-");
		var nodeID = Std.parseInt(HxOverrides.substr(strID,0,dotIndex));
		var taskID = HxOverrides.substr(strID,dotIndex + 1,dashIndex - dotIndex - 1);
		var targetID = Std.parseInt(HxOverrides.substr(strID,dashIndex + 1,null));
		var sect = null;
		var _g_head = this.game.player.sects.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var s = val;
			if(s.leader.id == nodeID) {
				sect = s;
				sect.isAdvisor = false;
				break;
			}
		}
		if(taskID == "doNothing") {
			sect.clearTask();
			this.show();
			return;
		}
		var task = null;
		var _g1 = 0;
		var _g2 = this.game.sectTasks;
		while(_g1 < _g2.length) {
			var t = _g2[_g1];
			++_g1;
			if(t.id == taskID) {
				task = t;
				break;
			}
		}
		if(task == null) {
			return;
		}
		var target = null;
		if(task.type == "cult") {
			target = this.game.cults[targetID];
		}
		sect.setTask(task,target);
		this.show();
	}
	,onShow: function() {
		var s = "<table class=uiListSects cellspacing=3 cellpadding=3>" + "<tr><th>Name<th>Puppeteer<th>LVL<th>Size<th>Current Task<th>AI";
		var _g_head = this.game.player.sects.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var sect = val;
			s += "<tr class=uiListSectsRow><td>" + sect.name + "<td>" + sect.leader.name + "<td style=\"text-align:center\">" + (sect.level + 1) + "<td style=\"text-align:center\">" + sect.size + "/" + sect.getMaxSize() + " <span class=uiListSectsPlus>(+" + sect.getGrowth() + ")</span>" + "<td>";
			s += "<select class=selectOption onchange='Game.instance.ui.sects.onSelect(this.value)'>";
			var _g = 0;
			var _g1 = this.game.sectTasks;
			while(_g < _g1.length) {
				var t = _g1[_g];
				++_g;
				if(t.type == "investigator" && !this.game.player.hasInvestigator) {
					continue;
				}
				if(t.level > sect.level) {
					continue;
				}
				if(t.type == "cult") {
					var _g2 = 0;
					var _g11 = this.game.cults;
					while(_g2 < _g11.length) {
						var c = _g11[_g2];
						++_g2;
						if(c == this.game.player || !c.isDiscovered[this.game.player.id] || c.isDead) {
							continue;
						}
						var ok = t.check(this.game.player,sect,c);
						if(!ok) {
							continue;
						}
						s += "<option class=selectOption value=" + sect.leader.id + "." + t.id + "-" + c.id + (sect.task != null && sect.task.id == t.id && sect.taskTarget == c ? " selected" : "") + ">" + t.getName(sect) + ": " + c.name;
					}
				} else if(t.type == "investigator" || t.type == "info") {
					var ok1 = t.check(this.game.player,sect,null);
					if(!ok1) {
						continue;
					}
					s += "<option class=selectOption value=" + sect.leader.id + "." + t.id + "-0 " + (sect.task != null && sect.task.id == t.id ? " selected" : "") + ">" + t.getName(sect);
				} else {
					s += "<option class=selectOption value=" + sect.leader.id + "." + t.id + "-0" + (sect.task != null && sect.task.id == t.id ? " selected" : "") + ">" + t.getName(sect);
				}
				if(sect.task != null && sect.task.id == t.id && !sect.task.isInfinite) {
					s += " (" + sect.taskPoints + "/" + sect.task.points + ")";
				}
			}
			s += "</select>";
			s += "<td style=\"text-align:center\">" + "<input type=\"checkbox\" name=\"sectai" + sect.leader.id + "\" " + (sect.isAdvisor ? "checked" : "") + " onchange=\"Game.instance.ui.sects.onAdvisor(" + sect.leader.id + ", this.checked)\">";
		}
		s += "</table>";
		this.list.innerHTML = s;
		this.text.innerHTML = "Sects: " + this.game.player.sects.length + "/" + (this.game.player.nodes.length / 4 | 0);
		this.window.style.display = "inline";
		this.bg.style.display = "inline";
		this.isVisible = true;
	}
	,onAdvisor: function(leaderID,checked) {
		var _g_head = this.game.player.sects.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var sect = val;
			if(sect.leader.id == leaderID) {
				sect.isAdvisor = checked;
				break;
			}
		}
	}
});
var Static = function() { };
Static.__name__ = true;
var UI = $hx_exports["UI"] = function(g) {
	this.game = g;
	this.config = new Config();
	this.fullscreen = false;
	window.devicePixelRatio = 1;
	window.onerror = $bind(this,this.onError);
	var url = window.location.href;
	var isClassic = StringTools.endsWith(url,"index.html") || StringTools.endsWith(url,"app-classic.html");
	if(StringTools.startsWith(url,"http")) {
		isClassic = true;
	}
	UI.classicMode = isClassic;
	UI.modernMode = !isClassic;
	UI.vars = isClassic ? UI.classicModeVars : UI.modernModeVars;
};
UI.__name__ = true;
UI.powerName = function(i,isShort) {
	if(isShort == null) {
		isShort = false;
	}
	return "<span class=shadow style='color:var(--power-color-" + i + ")'>" + (isShort ? Game.powerShortNames[i] : Game.powerNames[i]) + "</span>";
};
UI.cultName = function(i,info) {
	return "<span class='cultText shadow' style='color:" + UI.vars.cultColors[i] + "'>" + info.name + "</span>";
};
UI.e = function(s) {
	return window.document.getElementById(s);
};
UI.getVar = function(s) {
	return window.getComputedStyle(window.document.documentElement).getPropertyValue(s);
};
UI.getVarInt = function(s) {
	return Std.parseInt(window.getComputedStyle(window.document.documentElement).getPropertyValue(s));
};
UI.prototype = {
	onError: function(msg,url,line,col,err) {
		var d = new Date();
		var l = d.getHours() + ":" + (d.getMinutes() < 10 ? "0" : "") + d.getMinutes() + ":" + (d.getSeconds() < 10 ? "0" : "") + d.getSeconds() + " " + Std.string(msg) + ", " + Std.string(err.stack) + ", line " + line + ", col " + col + "\n";
		console.log("./jui/UI.hx:71:",l);
		return false;
	}
	,init: function() {
		this.logWindow = new Log(this,this.game);
		this.logPanel = new LogPanel(this,this.game);
		this.alertWindow = new Alert(this,this.game);
		this.info = new Info(this,this.game);
		this.debug = new Debug(this,this.game);
		this.status = new Status(this,this.game);
		this.map = new MapUI(this,this.game);
		this.music = new Music(this);
		this.mainMenu = new MainMenu(this,this.game);
		this.loadMenu = new LoadMenu(this,this.game);
		this.saveMenu = new SaveMenu(this,this.game);
		this.customMenu = new CustomMenu(this,this.game);
		this.mpMenu = new MultiplayerMenu(this,this.game);
		this.top = new TopMenu(this,this.game);
		this.sects = new SectsInfo(this,this.game);
		this.options = new OptionsMenu(this,this.game);
		this.manual = new Manual(this,this.game);
		this.messageWindow = new Message(this,this.game);
		this.music.onRandom = ($_=this.status,$bind($_,$_.onMusic));
		window.document.onkeyup = $bind(this,this.onKey);
		window.onresize = $bind(this,this.onResize);
		this.onResize(null);
	}
	,onResize: function(event) {
		this.map.resize();
		this.top.resize();
	}
	,onKey: function(e) {
		var key = e.keyCode;
		var windowOpen = this.loadMenu.isVisible || this.saveMenu.isVisible || this.mainMenu.isVisible || this.debug.isVisible || this.alertWindow.isVisible || this.logWindow.isVisible || this.info.isVisible || this.sects.isVisible || this.customMenu.isVisible || this.manual.isVisible;
		if(this.loadMenu.isVisible) {
			this.loadMenu.onKey(e);
		} else if(this.saveMenu.isVisible) {
			this.saveMenu.onKey(e);
		} else if(this.mainMenu.isVisible) {
			this.mainMenu.onKey(e);
		} else if(this.customMenu.isVisible) {
			this.customMenu.onKey(e);
		} else if(this.mpMenu.isVisible) {
			this.mpMenu.onKey(e);
		} else if(this.debug.isVisible) {
			this.debug.onKey(e);
		} else if(this.sects.isVisible) {
			this.sects.onKey(e);
		} else if(e.keyCode == 27 || e.keyCode == 13 || e.keyCode == 32) {
			if(e.keyCode == 13 && this.sects.isVisible) {
				return;
			}
			if(this.alertWindow.isVisible) {
				this.alertWindow.onClose(null);
			} else if(this.logWindow.isVisible) {
				this.logWindow.onClose(null);
			} else if(this.info.isVisible) {
				this.info.onClose(null);
			} else if(this.sects.isVisible) {
				this.sects.onClose(null);
			} else if(this.options.isVisible) {
				this.options.onClose(null);
			} else if(this.manual.isVisible) {
				this.manual.onClose(null);
			} else if(e.keyCode == 27) {
				this.fullscreen = false;
				this.game.player.options.set("fullscreen",false);
				this.mainMenu.show();
			}
		} else if(this.alertWindow.isVisible && this.alertWindow.isYesNo) {
			if(e.keyCode == 49) {
				this.alertWindow.onYes(null);
			} else if(e.keyCode == 50) {
				this.alertWindow.onClose(null);
			}
		} else if(this.logWindow.isVisible && e.keyCode == 76) {
			this.logWindow.onClose(null);
		} else if(this.info.isVisible && e.keyCode == 67) {
			this.info.onClose(null);
		} else if(this.options.isVisible && e.keyCode == 79) {
			this.options.onClose(null);
		} else if(this.manual.isVisible && e.keyCode == 77) {
			this.manual.onClose(null);
		} else if(!windowOpen) {
			if(e.keyCode == 65) {
				this.top.onAdvanced(null);
			} else if(e.keyCode == 67) {
				this.top.onCults(null);
			} else if(e.keyCode == 68) {
				this.top.onDebug(null);
			} else if(e.keyCode == 69) {
				this.status.onEndTurn(null);
			} else if(e.keyCode == 70) {
				this.setFullscreen(!this.fullscreen);
			} else if(e.keyCode == 76) {
				this.top.onLog(null);
			} else if(e.keyCode == 77) {
				this.manual.show();
			} else if(e.keyCode == 79) {
				this.top.onOptions(null);
			} else if(e.keyCode == 83) {
				this.top.onSects(null);
			} else if(e.keyCode == 49 && !this.game.isFinished) {
				this.game.player.upgrade(0);
			} else if(e.keyCode == 50 && !this.game.isFinished) {
				this.game.player.upgrade(1);
			} else if(e.keyCode == 51 && !this.game.isFinished) {
				this.game.player.upgrade(2);
			}
		}
	}
	,setFullscreen: function(val) {
		if(this.fullscreen) {
			window.document.exitFullscreen();
		} else {
			window.document.documentElement.requestFullscreen();
		}
		this.fullscreen = !this.fullscreen;
		this.game.player.options.set("fullscreen",val);
	}
	,clearMap: function() {
		this.map.clear();
	}
	,msg: function(s) {
		this.messageWindow.show(s);
	}
	,updateStatus: function() {
		this.status.update();
	}
	,finish: function(cult,state) {
		this.game.isFinished = true;
		this.status.update();
		var msg = "<div style='text-size: 20px'><b>GAME OVER</b></div><br>";
		var w = 600;
		var h = 250;
		if(state == "summon" && !cult.isAI) {
			msg += "The stars were right. The Elder God was summoned in " + this.game.turns + " turns.";
			msg += "<br><br><center><b>YOU WIN</b></center>";
			var action = "winGame diff:" + this.game.difficultyLevel;
			var label = "summon";
			var value = this.game.turns;
			action = "cult " + action + " " + Game.version;
			if(label == null) {
				label = "";
			}
			if(value == null) {
				value = 0;
			}
			h = 210;
		} else if(state == "summon" && cult.isAI) {
			var msg1 = cult.get_fullName() + " has completed the ";
			var _this = Static.rituals;
			msg += msg1 + (__map_reserved["summoning"] != null ? _this.getReserved("summoning") : _this.h["summoning"]).name + ".<br><br>" + cult.info.summonFinish;
			msg += "<br><br><center><b>YOU LOSE</b></center>";
			var action1 = "loseGame diff:" + this.game.difficultyLevel;
			var label1 = "summon";
			var value1 = this.game.turns;
			action1 = "cult " + action1 + " " + Game.version;
			if(label1 == null) {
				label1 = "";
			}
			if(value1 == null) {
				value1 = 0;
			}
			w = 700;
			h = 470;
		} else if(state == "conquer" && !cult.isAI) {
			msg += cult.get_fullName() + " has taken over the world in " + this.game.turns + " turns. The Elder Gods are pleased.";
			msg += "<br><br><center><b>YOU WIN</b></center>";
			var action2 = "winGame diff:" + this.game.difficultyLevel;
			var label2 = "conquer";
			var value2 = this.game.turns;
			action2 = "cult " + action2 + " " + Game.version;
			if(label2 == null) {
				label2 = "";
			}
			if(value2 == null) {
				value2 = 0;
			}
			h = 210;
		} else if(state == "conquer" && cult.isAI) {
			msg += cult.get_fullName() + " has taken over the world. You fail.";
			msg += "<br><br><center><b>YOU LOSE</b></center>";
			var action3 = "loseGame diff:" + this.game.difficultyLevel;
			var label3 = "conquer";
			var value3 = this.game.turns;
			action3 = "cult " + action3 + " " + Game.version;
			if(label3 == null) {
				label3 = "";
			}
			if(value3 == null) {
				value3 = 0;
			}
			h = 210;
		} else if(state == "wiped") {
			msg += cult.get_fullName() + " was wiped away completely. " + "The Elder God lies dormant beneath the sea, waiting.";
			msg += "<br><br><center><b>YOU LOSE</b></center>";
			var action4 = "loseGame diff:" + this.game.difficultyLevel;
			var label4 = "wiped";
			var value4 = this.game.turns;
			action4 = "cult " + action4 + " " + Game.version;
			if(label4 == null) {
				label4 = "";
			}
			if(value4 == null) {
				value4 = 0;
			}
			h = 210;
		} else if(state == "multiplayerFinish") {
			msg += "The great game has ended. Humanity will live.";
			msg += "<br><br><center><b>YOU ALL LOSE</b></center>";
			var action5 = "loseGame diff:" + this.game.difficultyLevel;
			var label5 = "multiplayerFinish";
			var value5 = this.game.turns;
			action5 = "cult " + action5 + " " + Game.version;
			if(label5 == null) {
				label5 = "";
			}
			if(value5 == null) {
				value5 = 0;
			}
			h = 190;
		}
		if(UI.classicMode) {
			h += 5;
		}
		var _g = 0;
		var _g1 = this.game.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			n.setVisible(this.game.player,true);
			n.isKnown[this.game.player.id] = true;
		}
		this.map.paint();
		this.alert(msg,{ w : w, h : h});
		this.alert("The game is over. After checking out the results you can open the main menu and start a new one.",{ w : 600, h : UI.classicMode ? 125 : 110});
	}
	,alert: function(s,opts) {
		this.alertWindow.show(s,opts);
	}
	,log2: function(cultOrigin,s,params) {
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.isDiscovered[cultOrigin.id] || cultOrigin.isDiscovered[c.id]) {
				c.log(s);
				if(params != null && params.type == "sect" && c.options.getBool("logPanelSkipSects")) {
					continue;
				}
				c.logPanel({ id : -1, old : false, type : null, text : s, obj : cultOrigin, turn : this.game.turns + 1, params : params});
			}
		}
	}
	,clearLog: function() {
		this.logWindow.clear();
		this.logPanel.clear();
	}
	,updateTip: function(name,tip) {
		name = "#" + name;
		if(name.indexOf(".") > 0) {
			name = HxOverrides.substr(name,0,name.indexOf(".")) + "\\" + HxOverrides.substr(name,name.indexOf("."),null);
		}
		new JQuery(name).attr("tooltipText",tip);
	}
	,track: function(action,label,value) {
		action = "cult " + action + " " + Game.version;
		if(label == null) {
			label = "";
		}
		if(value == null) {
			value = 0;
		}
	}
};
var Status = function(uivar,gvar) {
	var _gthis = this;
	this.ui = uivar;
	this.game = gvar;
	this.statusBorder = window.document.getElementById("statusBorder");
	this.status = window.document.getElementById("status");
	var s = "";
	s += "<div id=statusBG><div id=statusFG>";
	s += "<div id='status.cult'>-</div>";
	s += "<fieldset>";
	s += "<legend>FOLLOWERS</legend>";
	s += "<div class='uiButton statusConvert statusUpgrade' id='status-ritual-unveiling' style='visibility: hidden;'>U</div>";
	s += "<table class=statusTable cellpadding=0>";
	var _g = 0;
	var _g1 = Game.followerNames.length;
	while(_g < _g1) {
		var i = _g++;
		s += "<tr style='height:10;'><td id='status.follower" + i + "'>" + Game.followerNames[i] + "s";
		s += "<td><div class='uiButton statusConvert statusUpgrade' id='status.upgrade" + i + "' style='visibility: hidden;'>";
		if(i < Game.followerNames.length - 1) {
			s += "+";
		} else {
			s += "!";
		}
		s += "</div>";
		s += "<td><span class='statusNumber' id='status.followers" + i + "'>0</span>";
	}
	s += "</table></fieldset>";
	s += "<fieldset><legend>RESOURCES</legend>" + "<table class=statusTable cellpadding=0";
	s += UI.modernMode ? ">" : " cellspacing=0>";
	var _g2 = 0;
	var _g3 = Game.numPowers + 1;
	while(_g2 < _g3) {
		var i1 = _g2++;
		s += "<tr style='";
		if(UI.classicMode && i1 % 2 == 1) {
			s += "background:#101010";
		}
		s += "'><td>";
		if(UI.classicMode) {
			s += "<div class='status.powerMark' id='status.powerMark" + i1 + "' style='color: var(--power-color-" + i1 + ");'>" + Game.powerShortNames[i1] + "</div>";
		} else {
			s += "<img width=20 height=20 src='./data/power-" + Game.powerNames[i1].toLowerCase() + "-status.png'>";
		}
		s += "<td><span class=powerText id='status.powerName" + i1 + "'>" + UI.powerName(i1) + "</span>" + "<td><td><span id='status.power" + i1 + "'>0</span><br>" + "<span style='font-size:10px' id='status.powerMod" + i1 + "'>0</span>";
		s += "<tr style='";
		if(UI.classicMode && i1 % 2 == 1) {
			s += "background:#101010";
		}
		s += "'><td colspan=4><table class=statusResourceTable>" + "<tr><td width=20 halign=right>To";
		var _g21 = 0;
		var _g31 = Game.numPowers;
		while(_g21 < _g31) {
			var ii = _g21++;
			if(ii != i1) {
				s += "<td><div class='uiButton statusConvert' id='status.convert" + i1 + ii + "' " + "style='color: var(--power-color-" + ii + "); visibility: hidden;'>" + Game.powerShortNames[ii] + "</div>";
			}
		}
		if(i1 != 3) {
			s += "<td><div class='uiButton statusConvert' id='status.lowerAwareness" + i1 + "' " + "style='color:var(--awareness-color); visibility: hidden;'>A</div>";
			s += "<td halign=right>" + "<div class='uiButton statusConvert' id='status.lowerWillpower" + i1 + "' " + "style='color:var(--willpower-color); visibility: hidden;'>W</div>";
		}
		s += "</table>";
	}
	s += "</table></fieldset>";
	s += "<fieldset>";
	s += "<legend>STATS</legend>";
	s += "<table class=statusTable cellpadding=0>";
	s += "<tr id='status.awRow' title='" + Status.tipAwareness + "'><td>Awareness<td><span id='status.awareness'>0</span>";
	s += "<tr id='status.tuRow' title='" + Status.tipTurns + "'><td>Turns<td><span id='status.turns'>0</span>";
	s += "</table></fieldset>";
	s += "<center style='padding:15 0 2 0'>";
	s += "<span title='" + Status.tipEndTurn + "' id='status.endTurn' class='uiButton statusButton'>END TURN</span> ";
	s += "</center>";
	s += "<fieldset id='musicplayer'>";
	s += "<legend>MUSIC</legend>";
	s += "<div id='status.track'>-<br>-<br>-</div>";
	s += "<center style='padding-top:2px'>";
	s += "<span class='uiButton statusButton musicButton2' title='Play' id='status.play'>PLAY</span>&nbsp;&nbsp;";
	s += "<span class='uiButton statusButton musicButton2' title='Pause' id='status.pause'>PAUSE</span>&nbsp;&nbsp;";
	s += "<span class='uiButton statusButton musicButton2' title='Stop' id='status.stop'>STOP</span>&nbsp;&nbsp;";
	s += "<span class='uiButton statusButton musicButton2' title='Random track' id='status.random'>RANDOM</span>";
	s += "</center></fieldset>";
	s += "<center style='padding-top:12px;'><span class='uiButton statusButton' title='" + Status.tipMainMenu + "' id='status.mainMenu'>MAIN MENU</span></center>";
	if(Game.isDebug) {
		s += "<div id=status.debug></div>";
	}
	s += "</div></div>";
	this.status.innerHTML = s;
	var player = window.document.getElementById("musicplayer");
	var b = Tools.button({ id : "status.musicPlus", text : "+", className : "uiButton statusButton musicButton", w : null, h : null, x : null, y : null, container : player, title : "Click to increase music volume.", func : function(ev) {
		_gthis.ui.music.increaseVolume();
	}});
	b.style.position = null;
	var b1 = Tools.button({ id : "status.musicMinus", text : "-", className : "uiButton statusButton musicButton", w : null, h : null, x : null, y : null, container : player, title : "Click to decrease music volume.", func : function(ev1) {
		_gthis.ui.music.decreaseVolume();
	}});
	b1.style.position = null;
	var _g4 = 0;
	var _g5 = Game.followerNames.length;
	while(_g4 < _g5) {
		var i2 = _g4++;
		window.document.getElementById("status.follower" + i2).title = Status.tipFollowers[i2];
		var c = window.document.getElementById("status.upgrade" + i2);
		c.onclick = $bind(this,this.onUpgrade);
		c.title = Status.tipUpgrade[i2];
		c.style.visibility = "hidden";
	}
	window.document.getElementById("status-ritual-unveiling").onclick = $bind(this,this.onRitual);
	var _g6 = 0;
	var _g7 = Game.numPowers + 1;
	while(_g6 < _g7) {
		var i3 = _g6++;
		if(UI.classicMode) {
			window.document.getElementById("status.powerMark" + i3).title = Status.tipPowers[i3];
			window.document.getElementById("status.powerName" + i3).title = Status.tipPowers[i3];
		}
		var _g61 = 0;
		var _g71 = Game.numPowers;
		while(_g61 < _g71) {
			var ii1 = _g61++;
			if(i3 != ii1) {
				var c1 = window.document.getElementById("status.convert" + i3 + ii1);
				c1.onclick = $bind(this,this.onConvert);
				c1.title = Status.tipConvert + UI.powerName(ii1) + ": " + Game.powerConversionCost[i3];
			}
		}
		if(i3 != 3) {
			var c2 = window.document.getElementById("status.lowerAwareness" + i3);
			c2.onclick = $bind(this,this.onLowerAwareness);
			c2.title = Status.tipLowerAwareness;
			var c3 = window.document.getElementById("status.lowerWillpower" + i3);
			c3.onclick = $bind(this,this.onLowerWillpower);
			c3.title = Status.tipLowerWillpower + Game.willPowerCost;
		}
	}
	window.document.getElementById("status.endTurn").onclick = $bind(this,this.onEndTurn);
	window.document.getElementById("status.mainMenu").onclick = $bind(this,this.onMainMenu);
	window.document.getElementById("status.play").onclick = $bind(this,this.onPlay);
	window.document.getElementById("status.pause").onclick = $bind(this,this.onPause);
	window.document.getElementById("status.stop").onclick = $bind(this,this.onStop);
	window.document.getElementById("status.random").onclick = $bind(this,this.onRandom);
	new JQuery("#status *").tooltip({ delay : 0});
};
Status.__name__ = true;
Status.e = function(s) {
	return window.document.getElementById(s);
};
Status.prototype = {
	onPlay: function(event) {
		this.ui.music.play();
	}
	,onPause: function(event) {
		this.ui.music.pause();
	}
	,onStop: function(event) {
		this.ui.music.stop();
	}
	,onRandom: function(event) {
		this.ui.music.random();
	}
	,onLowerAwareness: function(event) {
		if(this.game.isFinished) {
			return;
		}
		var power = Std.parseInt(Tools.getTarget(event).id.substr(21,1));
		this.game.player.lowerAwareness(power);
	}
	,onLowerWillpower: function(event) {
		if(this.game.isFinished) {
			return;
		}
		var power = Std.parseInt(Tools.getTarget(event).id.substr(21,1));
		this.game.player.lowerWillpower(power);
	}
	,onUpgrade: function(event) {
		if(this.game.isFinished) {
			return;
		}
		var lvl = Std.parseInt(Tools.getTarget(event).id.substr(14,1));
		this.game.player.upgrade(lvl);
	}
	,onRitual: function(event) {
		if(this.game.isFinished) {
			return;
		}
		var id = Tools.getTarget(event).id.substr(14);
		this.game.player.startRitual(id);
	}
	,onConvert: function(event) {
		if(this.game.isFinished) {
			return;
		}
		var from = Std.parseInt(Tools.getTarget(event).id.substr(14,1));
		var to = Std.parseInt(Tools.getTarget(event).id.substr(15,1));
		this.game.player.convert(from,to);
	}
	,onEndTurn: function(event) {
		if(this.game.isFinished) {
			return;
		}
		this.game.player.highlightedNodes.clear();
		var _g_head = this.game.player.logPanelMessages.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var m = val;
			m.old = true;
		}
		this.game.endTurn();
	}
	,onMainMenu: function(event) {
		this.ui.mainMenu.show();
	}
	,updateTip: function(name,tip) {
		name = "#" + name;
		if(name.indexOf(".") > 0) {
			name = HxOverrides.substr(name,0,name.indexOf(".")) + "\\" + HxOverrides.substr(name,name.indexOf("."),null);
		}
		new JQuery(name).attr("tooltipText",tip);
	}
	,update: function() {
		window.document.getElementById("status.cult").innerHTML = this.game.player.get_fullName();
		var _g = 0;
		var _g1 = Game.numPowers + 1;
		while(_g < _g1) {
			var i = _g++;
			var s = Status.tipPowers[i] + "<br>Chance to gain each unit: <span class=shadow style='color:white'>" + this.game.player.getResourceChance() + "%</span>";
			this.updateTip("status.powerMark" + i,s);
			this.updateTip("status.powerName" + i,s);
		}
		var _g2 = 0;
		var _g3 = Game.followerLevels;
		while(_g2 < _g3) {
			var i1 = _g2++;
			this.updateTip("status.follower" + i1,Status.tipFollowers[i1]);
			this.updateTip("status.upgrade" + i1,Status.tipUpgrade[i1] + "<br>Chance of success: <span class=shadow style='color:white'>" + this.game.player.getUpgradeChance(i1) + "%</span>");
		}
		this.updateTip("status.followers1",(this.game.player.adeptsUsed > this.game.player.get_adepts() ? this.game.player.get_adepts() : this.game.player.adeptsUsed) + " used of " + this.game.player.get_adepts());
		var _g4 = 0;
		var _g5 = Game.numPowers + 1;
		while(_g4 < _g5) {
			var i2 = _g4++;
			var _g41 = 0;
			var _g51 = Game.numPowers;
			while(_g41 < _g51) {
				var ii = _g41++;
				if(i2 == ii) {
					continue;
				}
				var c = window.document.getElementById("status.convert" + i2 + ii);
				c.style.visibility = this.game.player.power[i2] >= Game.powerConversionCost[i2] && !this.game.isFinished ? "visible" : "hidden";
			}
		}
		var _g6 = 0;
		var _g7 = Game.followerLevels;
		while(_g6 < _g7) {
			var i3 = _g6++;
			var s1 = "" + this.game.player.getNumFollowers(i3);
			if(i3 == 1 && this.game.player.get_adepts() > 0) {
				var adepts = this.game.player.get_adepts() - this.game.player.adeptsUsed;
				if(adepts < 0) {
					adepts = 0;
				}
				s1 = "" + adepts;
			}
			var el = window.document.getElementById("status.followers" + i3);
			el.innerHTML = s1;
			if(i3 == 1 && this.game.player.get_adepts() > 0) {
				el.style.color = "var(--adepts-color)";
				el.className = "shadow statusNumber";
			} else {
				el.style.color = "var(--text-color)";
				el.className = "statusNumber";
			}
		}
		var _g8 = 0;
		var _g9 = Game.numPowers + 1;
		while(_g8 < _g9) {
			var i4 = _g8++;
			window.document.getElementById("status.power" + i4).innerHTML = "<b>" + this.game.player.power[i4] + "</b>";
			if(i4 == 3) {
				var t = " +0";
				if(this.game.player.maxVirgins() > 0) {
					t = " +0-" + this.game.player.maxVirgins();
				}
				window.document.getElementById("status.powerMod3").innerHTML = t;
			} else {
				var t1 = " +0";
				if(this.game.player.powerMod[i4] > 0) {
					t1 = " +0-" + this.game.player.powerMod[i4];
				}
				window.document.getElementById("status.powerMod" + i4).innerHTML = t1;
			}
		}
		window.document.getElementById("status.turns").innerHTML = "" + this.game.turns;
		var aw = window.document.getElementById("status.awareness");
		aw.innerHTML = "" + this.game.player.awareness + "%";
		var col = 0;
		if(this.game.player.awareness >= 20) {
			col = 2;
		} else if(this.game.player.awareness >= 10) {
			col = 1;
		}
		if(UI.modernMode) {
			aw.style.background = "var(--awareness-text-color-" + col + ")";
		} else {
			aw.style.color = "var(--awareness-text-color-" + col + ")";
		}
		aw.className = col > 0 ? "blinking" : "";
		var _g10 = 0;
		var _g11 = Game.numPowers;
		while(_g10 < _g11) {
			var i5 = _g10++;
			window.document.getElementById("status.lowerAwareness" + i5).style.visibility = "hidden";
		}
		if(!this.game.isFinished && this.game.player.adeptsUsed < this.game.player.get_adepts() && this.game.player.get_adepts() > 0 && this.game.player.awareness > 0) {
			var _g12 = 0;
			var _g13 = Game.numPowers;
			while(_g12 < _g13) {
				var i6 = _g12++;
				if(this.game.player.power[i6] > 0) {
					window.document.getElementById("status.lowerAwareness" + i6).style.visibility = "visible";
				}
			}
		}
		var _g121 = 0;
		var _g131 = Game.numPowers;
		while(_g121 < _g131) {
			var i7 = _g121++;
			window.document.getElementById("status.lowerWillpower" + i7).style.visibility = "hidden";
		}
		if(!this.game.isFinished && this.game.player.hasInvestigator && !this.game.player.investigator.isHidden && this.game.player.adeptsUsed < this.game.player.get_adepts() && this.game.player.get_adepts() > 0) {
			var _g14 = 0;
			var _g15 = Game.numPowers;
			while(_g14 < _g15) {
				var i8 = _g14++;
				if(this.game.player.power[i8] >= Game.willPowerCost) {
					window.document.getElementById("status.lowerWillpower" + i8).style.visibility = "visible";
				}
			}
		}
		var _g141 = 0;
		var _g151 = Game.followerNames.length;
		while(_g141 < _g151) {
			var i9 = _g141++;
			var tmp = window.document;
			var tmp1 = !this.game.isFinished && this.game.player.canUpgrade(i9);
			tmp.getElementById("status.upgrade" + i9).style.visibility = tmp1 ? "visible" : "hidden";
		}
		var tmp2 = !this.game.isFinished && this.game.player.canStartRitual("unveiling");
		window.document.getElementById("status-ritual-unveiling").style.visibility = tmp2 ? "visible" : "hidden";
		window.document.getElementById("status.endTurn").style.visibility = !this.game.isFinished ? "visible" : "hidden";
		var _this = Static.rituals;
		this.updateTip("status.follower2",(__map_reserved["summoning"] != null ? _this.getReserved("summoning") : _this.h["summoning"]).priests + " priests and " + this.game.difficulty.numSummonVirgins + " virgins are needed to summon the Elder God.");
		var _this1 = Static.rituals;
		var tmp3 = "To perform the " + (__map_reserved["summoning"] != null ? _this1.getReserved("summoning") : _this1.h["summoning"]).name + " you need ";
		var _this2 = Static.rituals;
		this.updateTip("status.upgrade2",tmp3 + (__map_reserved["summoning"] != null ? _this2.getReserved("summoning") : _this2.h["summoning"]).priests + " priests and " + this.game.difficulty.numSummonVirgins + " virgins.<br>" + "<li>The more society is aware of the cult the harder it is to " + "summon Elder God.");
		var _this3 = Static.rituals;
		this.updateTip("status-ritual-unveiling",(__map_reserved["unveiling"] != null ? _this3.getReserved("unveiling") : _this3.h["unveiling"]).note);
		if(Game.isDebug) {
			window.document.getElementById("status.debug").innerHTML = this.ui.info.getDebugInfo(this.game.player,true);
		}
	}
	,onMusic: function() {
		window.document.getElementById("status.track").innerHTML = this.ui.music.getName();
	}
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x, x && x[0]=="0" && (x[1]=="x" || x[1]=="X") ? 16 : 10);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
};
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	l -= s.length;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	buf_b += s == null ? "null" : "" + s;
	return buf_b;
};
var Tools = function() { };
Tools.__name__ = true;
Tools.getTarget = function(event) {
	if(event == null) {
		event = window.event;
	}
	var t = event.target;
	if(t == null) {
		t = event.srcElement;
	}
	return t;
};
Tools.bg = function(z) {
	if(z == null) {
		z = 15;
	}
	var bg = window.document.createElement("div");
	bg.className = "uiBG";
	bg.style.display = "none";
	bg.style.zIndex = z + "";
	window.document.body.appendChild(bg);
	return bg;
};
Tools.button = function(params) {
	var b = window.document.createElement("div");
	if(params.id != null) {
		b.id = params.id;
	}
	b.innerHTML = params.text;
	if(params.bold == null) {
		params.bold = true;
	}
	if(params.bold && UI.classicMode) {
		b.style.fontWeight = "bold";
	}
	b.className = params.className != null ? params.className : "uiButton";
	if(params.fontSize != null) {
		b.style.fontSize = params.fontSize + "px";
	}
	b.style.position = "absolute";
	if(params.w != null) {
		b.style.width = params.w + "px";
	}
	if(params.h != null) {
		b.style.height = params.h + "px";
	}
	if(params.x != null) {
		b.style.left = params.x + "px";
	}
	if(params.y != null) {
		b.style.top = params.y + "px";
	}
	params.container.appendChild(b);
	if(params.func != null) {
		b.onclick = params.func;
	}
	if(params.title != null) {
		b.title = params.title;
		new JQuery("#" + params.id).tooltip({ delay : 0});
	}
	return b;
};
Tools.closeButton = function(container) {
	var w = Std.parseInt(container.style.width);
	var b = Tools.button({ id : null, text : "Close", w : 80, h : null, x : null, y : null, container : container});
	b.style.left = "50%";
	b.style.bottom = "var(--close-button-bottom)";
	b.style.transform = "translate(-50%)";
	return b;
};
Tools.label = function(params) {
	var b = window.document.createElement("div");
	b.id = params.id;
	b.innerHTML = params.text;
	var rect = b.getBoundingClientRect();
	if(params.bold == null) {
		params.bold = true;
	}
	if(params.bold && UI.classicMode) {
		b.style.fontWeight = "bold";
	}
	b.style.fontSize = params.fontSize + "px";
	b.style.position = "absolute";
	if(UI.modernMode) {
		b.style.textTransform = "uppercase";
	}
	if(params.w != null) {
		b.style.width = params.w + "px";
	}
	b.style.height = params.h + "px";
	if(params.x != null) {
		b.style.left = params.x + "px";
	}
	b.style.top = params.y + "px";
	b.style.userSelect = "none";
	b.style.color = "var(--text-color)";
	params.container.appendChild(b);
	return b;
};
Tools.window = function(params) {
	var x = (window.innerWidth - params.w) / 2 | 0;
	var y = (window.innerHeight - params.h) / 2 | 0;
	if(params.z == null) {
		params.z = 10;
	}
	if(UI.modernMode) {
		params.h += 16;
	}
	if(params.border == null) {
		params.border = true;
	}
	var border = null;
	if(params.border) {
		border = window.document.createElement("div");
		if(params.id != null) {
			border.id = params.id + "Border";
		}
		window.document.body.appendChild(border);
		border.className = "uiWindowBorder";
		border.style.display = "none";
		border.style.zIndex = params.z + "";
		if(params.w != null) {
			border.style.width = params.w + "px";
		}
		if(params.h != null) {
			border.style.height = params.h + "px";
		}
	}
	var w = window.document.createElement("div");
	if(params.id != null) {
		w.id = params.id + "Window";
	}
	w.className = "uiWindow";
	if(params.fontSize != null) {
		w.style.fontSize = params.fontSize + "px";
	}
	if(params.bold) {
		w.style.fontWeight = "bold";
	}
	if(params.w != null) {
		w.style.width = params.w - 16 + "px";
	}
	if(params.h != null) {
		w.style.height = params.h - 16 + "px";
	}
	if(params.border) {
		border.appendChild(w);
	} else {
		window.document.body.appendChild(w);
	}
	if(params.shadowLayer == null) {
		params.shadowLayer = 15;
	}
	if(params.shadowLayer > 0) {
		var bg = Tools.bg(params.shadowLayer);
		if(params.id != null) {
			bg.id = params.id + "BG";
		}
	}
	return w;
};
Tools.textfield = function(params) {
	var t = window.document.createElement("input");
	t.id = params.id;
	t.className = "selectOption";
	t.value = params.text;
	if(params.bold == null) {
		params.bold = false;
	}
	if(params.bold) {
		t.style.fontWeight = "bold";
	}
	if(params.fontSize == null) {
		params.fontSize = 20;
	}
	t.style.fontSize = params.fontSize + "px";
	t.style.width = params.w + "px";
	t.style.height = params.h + "px";
	t.style.left = params.x + "px";
	t.style.top = params.y + "px";
	t.style.position = "absolute";
	t.style.padding = "0px 5px 0px 5px";
	params.container.appendChild(t);
	return t;
};
Tools.checkbox = function(params) {
	var t = window.document.createElement("input");
	t.id = params.id;
	t.value = params.text;
	t.type = "checkbox";
	if(params.bold == null) {
		params.bold = false;
	}
	if(params.bold) {
		t.style.fontWeight = "bold";
	}
	if(params.fontSize == null) {
		params.fontSize = 20;
	}
	t.style.color = "#ffffff";
	t.style.fontSize = params.fontSize + "px";
	t.style.position = "absolute";
	t.style.width = params.w + "px";
	if(params.h != null) {
		t.style.height = params.h + "px";
	}
	t.style.left = params.x + "px";
	t.style.top = params.y + "px";
	t.style.background = "#111";
	t.style.paddingLeft = "5px";
	t.style.border = "1px outset #777";
	params.container.appendChild(t);
	return t;
};
var TopMenu = function(uivar,gvar) {
	var _gthis = this;
	this.ui = uivar;
	this.game = gvar;
	this.panel = window.document.createElement("div");
	this.panel.id = "topPanel";
	window.document.body.appendChild(this.panel);
	Tools.button({ id : "cults", text : "CULTS", className : "topButton uiButton", w : 70, h : null, x : 20, y : null, container : this.panel, title : "Click to view cults information (or press <span class=shadow style=\"color:white\">C</span>).", func : $bind(this,this.onCults)});
	Tools.button({ id : "sects", text : "SECTS", className : "topButton uiButton", w : 70, h : null, x : 110, y : null, container : this.panel, title : "Click to view sects controlled by your cult (or press <span class=shadow style=\"color:white\">S</span>).", func : $bind(this,this.onSects)});
	Tools.button({ id : "log", text : "LOG", className : "topButton uiButton", w : 70, h : null, x : 200, y : null, container : this.panel, title : "Click to view message log (or press <span class=shadow style=\"color:white\">L</span>).", func : $bind(this,this.onLog)});
	Tools.button({ id : "options", text : "OPTIONS", className : "topButton uiButton", w : 100, h : null, x : 290, y : null, container : this.panel, title : "Click to view options (or press <span class=shadow style=\"color:white\">O</span>).", func : $bind(this,this.onOptions)});
	if(Game.isDebug) {
		Tools.button({ id : "debug", text : "DEBUG", className : "topButton uiButton", w : 70, h : null, x : 410, y : null, container : this.panel, title : "Click to open debug menu (or press <span class=shadow style=\"color:white\">D</span>).", func : $bind(this,this.onDebug)});
	}
	this.manual = Tools.button({ id : "manual", text : "MANUAL", className : "topButton uiButton", w : 84, h : null, x : 597, y : null, container : this.panel, title : "Click&nbsp;to&nbsp;open&nbsp;the&nbsp;manual&nbsp;(or&nbsp;press&nbsp;<span class=shadow style=\"color:white\">M</span>).", func : function(event) {
		window.open("https://github.com/infidel-/cult/wiki/Manual");
	}});
	this.about = Tools.button({ id : "about", text : "ABOUT", className : "topButton uiButton", w : 70, h : null, x : 700, y : null, container : this.panel, title : "Click&nbsp;to&nbsp;open&nbsp;About&nbsp;page.", func : function(event1) {
		_gthis.ui.alert("<center style=\"font-size:19px;font-weight:bold\">About</center><br>" + "Code by Max Kowarski &lt;starinfidel@gmail.com&gt;<br>" + "Texts by Phil Bordelon &lt;<a target=_blank href=\"http://blortblort.org/\">blortblort.org</a>&gt;<br>" + "Music by Jeremy Rice &lt;<a target=_blank href=\"https://curious-inversions.bandcamp.com\">curious-inversions.bandcamp.com</a>&gt;<br><br>" + "<span style=\"font-size:12px\">Unfortunately, due to the fact that the music sources were lost at some point, you cannot purchase the music you listen to in the game. But there's a lot of newer works on the Bandcamp page, please check it out.</span><br><br>" + "Unceasing gratitude to the man who has acquainted us all with the blasphemous effulgence of cosmic horror - H.P.Lovecraft.<br><br>" + "This project uses icons made by Pixel perfect, Nikita Golubev, Vitaly Gorbachev, wanicon, and Freepik from <a target=_blank href=\"https://www.flaticon.com\">www.flaticon.com</a>.",{ w : 750, h : 300, center : false, fontSize : 14});
	}});
	this.advanced = Tools.button({ id : "advanced", text : "A", w : 12, h : 12, x : 774, y : 29, fontSize : 10, container : this.panel, title : "Click&nbsp;to&nbsp;toggle&nbsp;advanced&nbsp;map&nbsp;mode&nbsp;(or&nbsp;press&nbsp;<span class=shadow style=\"color:white\">A</span>).", func : $bind(this,this.onAdvanced)});
	if(UI.modernMode) {
		this.advanced.style.top = "25px";
	}
};
TopMenu.__name__ = true;
TopMenu.prototype = {
	onCults: function(event) {
		this.ui.info.show();
	}
	,onSects: function(e) {
		this.ui.sects.show();
	}
	,onLog: function(event) {
		this.ui.logWindow.show();
	}
	,onOptions: function(event) {
		this.ui.options.show();
	}
	,onDebug: function(event) {
		if(this.game.isFinished || !Game.isDebug) {
			return;
		}
		this.ui.debug.show();
	}
	,onAdvanced: function(event) {
		this.game.player.options.set("mapAdvancedMode",!this.game.player.options.getBool("mapAdvancedMode"));
		this.ui.map.paint();
	}
	,resize: function() {
		var panelRect = this.panel.getBoundingClientRect();
		this.panel.style.width = window.innerWidth - panelRect.left - 8 + "px";
		var x = Std.parseInt(this.panel.style.width) - Std.parseInt(this.about.style.width) - 30;
		this.about.style.left = x + "px";
		x -= Std.parseInt(this.manual.style.width) + 20;
		this.manual.style.left = x + "px";
		var marginx = Std.parseInt(window.getComputedStyle(window.document.documentElement).getPropertyValue("--advanced-mode-margin-x"));
		this.advanced.style.left = window.innerWidth - Std.parseInt(this.advanced.style.width) - panelRect.left - marginx + "px";
	}
};
var Tutorial = function(g,ui) {
	this.game = g;
	this.ui = ui;
	this.tags = new haxe_ds_StringMap();
};
Tutorial.__name__ = true;
Tutorial.prototype = {
	disable: function(tag) {
		if(!this.game.isTutorial) {
			return;
		}
		var _this = this.tags;
		if(__map_reserved[tag] != null) {
			_this.setReserved(tag,true);
		} else {
			_this.h[tag] = true;
		}
	}
	,play: function(tag) {
		if(!this.game.isTutorial) {
			return;
		}
		var _this = this.tags;
		if(__map_reserved[tag] != null ? _this.getReserved(tag) : _this.h[tag]) {
			return;
		}
		var _this1 = this.tags;
		if(__map_reserved[tag] != null) {
			_this1.setReserved(tag,true);
		} else {
			_this1.h[tag] = true;
		}
		var _this2 = Tutorial.strings;
		var str = __map_reserved[tag] != null ? _this2.getReserved(tag) : _this2.h[tag];
		var _g = 0;
		while(_g < str.length) {
			var s = str[_g];
			++_g;
			this.ui.alert(s,{ h : 180});
		}
	}
};
var Type = function() { };
Type.__name__ = true;
Type.createInstance = function(cl,args) {
	return new (Function.prototype.bind.apply(cl,[null].concat(args)));
};
var UINode = function(gvar,uivar,nvar) {
	this.game = gvar;
	this.ui = uivar;
	this.node = nvar;
};
UINode.__name__ = true;
UINode.prototype = {
	paint: function(ctx) {
		if(!this.node.visibility[this.game.player.id]) {
			return;
		}
		if(!this.inViewRect(UI.vars.markerWidth)) {
			return;
		}
		var key = "";
		var xx = this.node.x;
		var yy = this.node.y;
		var hlx = this.node.x - 10;
		var hly = this.node.y - 10;
		var tx = this.node.x + 4;
		var ty = this.node.y + 14;
		var text = "";
		var textColor = "white";
		var isI = false;
		var is1 = false;
		var _g = 0;
		var _g1 = Game.numPowers;
		while(_g < _g1) {
			var i = _g++;
			if(this.node.power[i] > 0) {
				text = Game.powerShortNames[i];
				textColor = window.getComputedStyle(window.document.documentElement).getPropertyValue("--power-color-" + i);
				isI = false;
				if(Game.powerShortNames[i] == "I") {
					isI = true;
				}
			}
		}
		if(this.node.owner != null) {
			key = "c";
			text = "" + (this.node.level + 1);
			textColor = "white";
			if(this.node.sect != null) {
				text = "S";
			}
			if(!this.node.isKnown[this.game.player.id]) {
				text = "?";
			}
		} else {
			key = "neutral";
		}
		var dd = 0;
		this.tempd = 0;
		this.temph = 17;
		if(this.node.isGenerator) {
			key += "g";
			dd = 2;
		}
		var _g2 = 0;
		var _g3 = this.game.cults;
		while(_g2 < _g3.length) {
			var p = _g3[_g2];
			++_g2;
			if(p.origin == this.node && !p.isDead && this.node.isKnown[this.game.player.id]) {
				key = "o";
				dd = 4;
				break;
			}
		}
		if(this.node.isProtected) {
			key += "p";
		}
		xx -= dd;
		yy -= dd;
		this.temph += dd * 2;
		this.tempd = dd;
		if(isI) {
			tx += 2;
		}
		xx -= this.ui.map.viewRect.x;
		yy -= this.ui.map.viewRect.y;
		tx -= this.ui.map.viewRect.x;
		ty -= this.ui.map.viewRect.y;
		hlx -= this.ui.map.viewRect.x;
		hly -= this.ui.map.viewRect.y;
		var _g4_head = this.game.player.highlightedNodes.h;
		while(_g4_head != null) {
			var val = _g4_head.item;
			_g4_head = _g4_head.next;
			var n = val;
			if(n == this.node) {
				if(UI.classicMode) {
					ctx.drawImage(this.ui.map.nodeImage,0,167,37,37,hlx,hly,37,37);
				} else {
					ctx.drawImage(this.ui.map.nodeHL,hlx * this.ui.map.zoom,hly * this.ui.map.zoom,this.ui.map.nodeHL.width * this.ui.map.zoom,this.ui.map.nodeHL.height * this.ui.map.zoom);
				}
				break;
			}
		}
		var a = Reflect.field(UINode.imageKeys,key);
		var y0 = a[0];
		var w = a[1];
		var x0 = this.node.owner != null ? this.node.owner.id * w : 0;
		if(UI.classicMode) {
			ctx.drawImage(this.ui.map.nodeImage,x0,y0,w,w,xx,yy,w,w);
			ctx.fillStyle = textColor;
			ctx.fillText(text,tx,ty);
		} else {
			var idx = 8;
			if(this.node.owner != null) {
				idx = this.node.owner.id;
			} else {
				text = "-";
			}
			var img = this.node.isGenerator ? this.ui.map.nodeImagesGenerator[idx] : this.ui.map.nodeImages[idx];
			ctx.drawImage(img,xx * this.ui.map.zoom,yy * this.ui.map.zoom,img.width * this.ui.map.zoom,img.height * this.ui.map.zoom);
			var imageID = this.node.imageID;
			if(key == "o" || key == "op") {
				imageID = 14;
			}
			var img1 = this.ui.map.jobImages[imageID];
			ctx.drawImage(img1,(xx + UINode.jobInfo[imageID].x) * this.ui.map.zoom,(yy + UINode.jobInfo[imageID].y + 6) * this.ui.map.zoom,img1.width * this.ui.map.zoom,img1.height * this.ui.map.zoom);
			if(this.node.owner != this.game.player && !this.game.player.options.getBool("mapAdvancedMode") && (this.node.isKnown[this.game.player.id] || this.node.owner == null)) {
				var _g5 = 0;
				var _g6 = Game.numPowers;
				while(_g5 < _g6) {
					var i1 = _g5++;
					if(this.node.power[i1] > 0) {
						var img2 = this.ui.map.powerImages[i1];
						ctx.drawImage(img2,(xx + 1) * this.ui.map.zoom,yy * this.ui.map.zoom,img2.width * this.ui.map.zoom,img2.height * this.ui.map.zoom);
						break;
					}
				}
			}
			var _this = MapUI.textToIndex;
			var img3 = this.ui.map.textImages[__map_reserved[text] != null ? _this.getReserved(text) : _this.h[text]];
			ctx.drawImage(img3,(xx + 39) * this.ui.map.zoom,(yy + 1) * this.ui.map.zoom,img3.width * this.ui.map.zoom,img3.height * this.ui.map.zoom);
		}
		this.tempx = xx;
		this.tempy = yy;
	}
	,paintAdvanced: function(ctx) {
		if(!this.node.visibility[this.game.player.id]) {
			return;
		}
		if(!this.inViewRect(UI.vars.markerWidth)) {
			return;
		}
		var productionIndicatorWidth = 6;
		var productionIndicatorHeight = 2;
		if(this.node.isGenerator && !this.node.isTempGenerator) {
			if(this.node.owner != this.game.player || this.node.isKnown[this.game.player.id]) {
				var j = 0;
				var _g = 0;
				var _g1 = Game.numPowers;
				while(_g < _g1) {
					var i = _g++;
					if(this.node.powerGenerated[i] > 0) {
						if(this.node.powerGenerated[i] == 0) {
							continue;
						}
						ctx.fillStyle = this.ui.map.powerColors[i];
						if(UI.classicMode) {
							ctx.fillRect(this.tempx + (this.tempd - 1) + i * (productionIndicatorWidth + 1),this.tempy - productionIndicatorHeight,productionIndicatorWidth,productionIndicatorHeight);
						} else {
							ctx.shadowColor = "black";
							ctx.fillText(UINode.roman[this.node.powerGenerated[i]],this.ui.map.zoom * (this.tempx + 62),this.ui.map.zoom * (this.tempy + 26 + j * 16));
							ctx.shadowColor = "transparent";
						}
						++j;
					}
				}
			}
		}
		if(this.node.owner != this.game.player) {
			var ch = this.game.player.getGainChance(this.node);
			if(UI.classicMode) {
				this.ui.map.paintText(ctx,[ch / 10 | 0,ch % 10,10],0,this.tempx + this.tempd + 1,this.tempy - 11);
			} else {
				ctx.fillStyle = "#402b2b";
				ctx.shadowOffsetX = 1;
				ctx.shadowOffsetY = 1;
				ctx.shadowBlur = 1;
				ctx.shadowColor = "#84aa9d";
				ctx.fillText(ch + "%",this.ui.map.zoom * (this.tempx + 13),this.ui.map.zoom * (this.tempy - 4));
				ctx.shadowColor = "transparent";
			}
			if(this.node.owner == null || this.node.isKnown[this.game.player.id]) {
				var j1 = 0;
				var _g2 = 0;
				var _g11 = Game.numPowers;
				while(_g2 < _g11) {
					var i1 = _g2++;
					if(this.node.power[i1] == 0) {
						continue;
					}
					if(UI.classicMode) {
						if(this.node.power[i1] > 0) {
							this.ui.map.paintText(ctx,[this.node.power[i1]],j1 + 1,this.tempd + this.tempx + j1 * 6,this.tempy + this.temph + 3);
						} else {
							this.ui.map.paintText(ctx,[10],i1 + 1,this.tempd + this.tempx + j1 * 6,this.tempy + this.temph + 3);
						}
					} else {
						ctx.shadowColor = "black";
						ctx.fillStyle = this.ui.map.powerColors[i1];
						var s = UINode.roman[this.node.power[i1]];
						var w = ctx.measureText(s).width;
						ctx.fillText(s,this.ui.map.zoom * (this.tempx - 4 - w),this.ui.map.zoom * (this.tempy + 26 + j1 * 16));
						ctx.shadowColor = "transparent";
					}
					++j1;
				}
			}
		}
	}
	,inViewRect: function(border) {
		if(this.node.x * this.ui.map.zoom < (this.ui.map.viewRect.x - border) * this.ui.map.zoom || this.node.y * this.ui.map.zoom < (this.ui.map.viewRect.y - border) * this.ui.map.zoom || this.node.x * this.ui.map.zoom > this.ui.map.viewRect.x * this.ui.map.zoom + this.ui.map.viewRect.w + UI.vars.markerWidth * this.ui.map.zoom || this.node.y * this.ui.map.zoom > this.ui.map.viewRect.y + this.ui.map.viewRect.h + UI.vars.markerHeight * this.ui.map.zoom) {
			return false;
		}
		return true;
	}
	,update: function() {
	}
	,getTooltip: function() {
		if(!this.node.visibility[this.game.player.id]) {
			return "";
		}
		var s = "";
		if(Game.debugNear) {
			s += "Node " + this.node.id + " (" + this.node.x + "," + this.node.y + ")<br>";
			s += "Links: ";
			var _g_head = this.node.links.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var n = val;
				s += n.id + " ";
			}
			if(this.node.isProtected) {
				s += "<br>Protected<br>";
			} else {
				s += "<br>Unprotected<br>";
			}
		}
		if(Game.debugVis) {
			s += "Node " + this.node.id + "<br>";
			var _g = 0;
			var _g1 = this.game.difficulty.numCults;
			while(_g < _g1) {
				var i = _g++;
				s += Std.string(this.node.visibility[i]) + "<br>";
			}
		}
		if(this.node.owner != null && !this.node.owner.isInfoKnown[this.game.player.id] && !this.node.isKnown[this.game.player.id] && this.node.owner != this.game.player) {
			s += "<span class=shadow style='color:var(--node-error-color)'>Use sects to gather cult<br>or node information.</span><br>";
			if(this.node.owner == null || this.node.owner != this.game.player) {
				s += "<br>Chance of success: <span class=shadow style='color:white'>" + this.game.player.getGainChance(this.node) + "%</span><br>";
			}
			return s;
		}
		if(this.node.owner != null) {
			s += UI.cultName(this.node.owner.id,this.node.owner.info) + "<br>";
			if(this.node.owner.origin == this.node && this.node.isKnown[this.game.player.id]) {
				s += "<span class=shadow style='color:" + UI.vars.cultColors[this.node.owner.id] + "'>The Origin</span><br>";
			}
			s += "<br>";
		}
		s += "<span class=shadow style='color:white'>" + this.node.name + "</span><br>";
		s += this.node.job + "<br>";
		if(this.node.owner != null) {
			s += "<b>" + (this.node.isKnown[this.game.player.id] ? Game.followerNames[this.node.level] : "Unknown") + "</b> <span class=shadow style='color:white'>L" + (this.node.isKnown[this.game.player.id] ? "" + (this.node.level + 1) : "?") + "</span><br>";
		}
		s += "<br>";
		if(this.node.sect != null) {
			s += "Leader of<br>" + this.node.sect.name + "<br><br>";
		}
		if(this.node.owner != this.game.player) {
			var br = false;
			if(this.node.isKnown[this.game.player.id] || this.node.owner == null) {
				var _g2 = 0;
				var _g11 = Game.numPowers;
				while(_g2 < _g11) {
					var i1 = _g2++;
					if(this.game.player.power[i1] < this.node.power[i1]) {
						s += "<span class=shadow style='color:var(--node-error-color)'>Not enough " + Game.powerNames[i1] + "</span><br>";
						br = true;
					}
				}
			}
			if(this.node.isGenerator && this.node.owner != null) {
				var cnt = 0;
				var _g_head1 = this.node.links.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var n1 = val1;
					if(n1.owner == this.node.owner) {
						++cnt;
					}
				}
				if(cnt >= 3) {
					s += "<span class=shadow style='color:var(--node-error-color)'>Generator has " + cnt + " links</span><br>";
				}
			}
			if(br) {
				s += "<br>";
			}
		}
		if(this.node.owner == null || this.node.isKnown[this.game.player.id]) {
			var _g3 = 0;
			var _g12 = Game.numPowers;
			while(_g3 < _g12) {
				var i2 = _g3++;
				if(this.node.power[i2] > 0) {
					s += "<b>" + UI.powerName(i2) + "</b> " + this.node.power[i2] + "<br>";
				}
			}
		}
		if(this.node.owner == null || this.node.owner.isAI) {
			s += "Chance of success: <span class=shadow style='color:white'>" + this.game.player.getGainChance(this.node) + "%</span><br>";
		}
		if(this.node.isGenerator && (this.node.owner == null || this.node.isKnown[this.game.player.id])) {
			s += "<br>Generates:<br>";
			var _g4 = 0;
			var _g13 = Game.numPowers;
			while(_g4 < _g13) {
				var i3 = _g4++;
				if(this.node.powerGenerated[i3] > 0) {
					s += "<b>" + UI.powerName(i3) + "</b> " + this.node.powerGenerated[i3] + "<br>";
				}
			}
			if(this.node.isTempGenerator) {
				s += "Temporary<br>";
			}
		}
		if(Game.isDebug) {
			var d = 1000000.0;
			var _g5 = 0;
			var _g14 = this.game.nodes;
			while(_g5 < _g14.length) {
				var n2 = _g14[_g5];
				++_g5;
				if(n2 != this.node) {
					var dx = n2.distance(this.node);
					if(dx < d) {
						d = dx;
					}
				}
			}
			s += "DBG dist nearest: " + (d | 0) + "<br>";
		}
		return s;
	}
	,setVisible: function(c,v) {
		if(c.isAI) {
			return;
		}
		if(Game.mapVisible) {
			v = true;
		}
	}
};
var haxe_ds_List = function() {
	this.length = 0;
};
haxe_ds_List.__name__ = true;
haxe_ds_List.prototype = {
	add: function(item) {
		var x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,first: function() {
		if(this.h == null) {
			return null;
		} else {
			return this.h.item;
		}
	}
	,pop: function() {
		if(this.h == null) {
			return null;
		}
		var x = this.h.item;
		this.h = this.h.next;
		if(this.h == null) {
			this.q = null;
		}
		this.length--;
		return x;
	}
	,clear: function() {
		this.h = null;
		this.q = null;
		this.length = 0;
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
haxe_ds__$List_ListNode.__name__ = true;
var haxe_ds__$StringMap_StringMapIterator = function(map,keys) {
	this.map = map;
	this.keys = keys;
	this.index = 0;
	this.count = keys.length;
};
haxe_ds__$StringMap_StringMapIterator.__name__ = true;
haxe_ds__$StringMap_StringMapIterator.prototype = {
	hasNext: function() {
		return this.index < this.count;
	}
	,next: function() {
		var _this = this.map;
		var key = this.keys[this.index++];
		if(__map_reserved[key] != null) {
			return _this.getReserved(key);
		} else {
			return _this.h[key];
		}
	}
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,remove: function(key) {
		if(__map_reserved[key] != null) {
			key = "$" + key;
			if(this.rh == null || !this.rh.hasOwnProperty(key)) {
				return false;
			}
			delete(this.rh[key]);
			return true;
		} else {
			if(!this.h.hasOwnProperty(key)) {
				return false;
			}
			delete(this.h[key]);
			return true;
		}
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = o.length;
			while(_g3 < _g11) {
				var i = _g3++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var sects_Advisor = function(g) {
	this.game = g;
};
sects_Advisor.__name__ = true;
sects_Advisor.prototype = {
	cultHasSectOnTask: function(cult,id,target) {
		var _g_head = cult.sects.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var s = val;
			if(s.task != null && s.task.id == id && s.taskTarget == target) {
				return true;
			}
		}
		return false;
	}
	,findBestSectForTask: function(cult,id,taskVeryImportant) {
		var task = null;
		var _g = 0;
		var _g1 = this.game.sectTasks;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			if(t.id == id) {
				task = t;
				break;
			}
		}
		var largestSect = null;
		var largestSize = 0;
		var minimalSect = null;
		var minimalSize = 10000;
		var _g2_head = cult.sects.h;
		while(_g2_head != null) {
			var val = _g2_head.item;
			_g2_head = _g2_head.next;
			var s = val;
			if(!s.isAdvisor) {
				continue;
			}
			if(s.taskImportant && !taskVeryImportant) {
				continue;
			}
			if(s.size >= task.points && s.size < minimalSize) {
				minimalSect = s;
				minimalSize = s.size;
			}
			if(s.size > largestSize) {
				largestSect = s;
				largestSize = s.size;
			}
		}
		if(minimalSect != null) {
			return minimalSect;
		}
		return largestSect;
	}
	,run: function(cult) {
		if(cult.sects.length == 0) {
			return;
		}
		if(cult.hasInvestigator && cult.investigator.isHidden) {
			if(!this.cultHasSectOnTask(cult,"invSearch")) {
				var s = this.findBestSectForTask(cult,"invSearch",true);
				if(s == null) {
					return;
				}
				s.setTaskByID("invSearch");
				s.taskImportant = true;
			}
		} else if(cult.hasInvestigator) {
			var _g_head = cult.sects.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var s1 = val;
				if((s1.task == null || s1.task.id != "invConfuse") && s1.isAdvisor) {
					s1.setTaskByID("invConfuse");
					s1.taskImportant = true;
				}
			}
			return;
		}
		var ritualCult = null;
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c != cult && c.isRitual && c.ritual.id == "summoning") {
				ritualCult = c;
				break;
			}
		}
		if(ritualCult != null) {
			var _g2_head = cult.sects.h;
			while(_g2_head != null) {
				var val1 = _g2_head.item;
				_g2_head = _g2_head.next;
				var s2 = val1;
				if((s2.task == null || !s2.taskImportant) && s2.isAdvisor && s2.level >= 1) {
					s2.setTaskByID("cultSabotageRitual",ritualCult);
					s2.taskImportant = true;
				}
			}
		}
		var _g2 = 0;
		var _g3 = this.game.cults;
		while(_g2 < _g3.length) {
			var c2 = _g3[_g2];
			++_g2;
			if(c2 == cult || !c2.isDiscovered[cult.id] || c2.isInfoKnown[cult.id]) {
				continue;
			}
			if(this.cultHasSectOnTask(cult,"cultGeneralInfo")) {
				continue;
			}
			var s3 = this.findBestSectForTask(cult,"cultGeneralInfo",false);
			if(s3 == null) {
				break;
			}
			s3.setTaskByID("cultGeneralInfo");
			s3.taskImportant = true;
		}
		var _g4_head = cult.sects.h;
		while(_g4_head != null) {
			var val2 = _g4_head.item;
			_g4_head = _g4_head.next;
			var s4 = val2;
			if((s4.task == null || !s4.taskImportant) && s4.isAdvisor) {
				s4.setTaskByID("cultNodeInfo");
			}
		}
	}
};
var sects_Task = function(g,ui) {
	this.game = g;
	this.ui = ui;
	this.id = "_empty";
	this.type = "";
	this.name = "";
	this.level = 0;
	this.points = 0;
	this.isInfinite = false;
};
sects_Task.__name__ = true;
sects_Task.prototype = {
	getName: function(sect) {
		return this.name;
	}
	,check: function(cult,sect,target) {
		console.log("sects/Task.hx:40:","default check(), should not be called!");
		return true;
	}
	,checkFailure: function(sect) {
		return false;
	}
	,complete: function(cult,sect,points) {
		console.log("sects/Task.hx:55:","default complete(), should not be called!");
	}
	,log: function(cult,m) {
		cult.log(m);
		var params = { symbol : "s"};
		cult.logPanel({ id : -1, old : false, type : "cult", text : m, obj : cult, turn : cult.game.turns + 1, params : params == null ? { } : params});
	}
};
var sects_CultGeneralInfoTask = function(g,ui) {
	sects_Task.call(this,g,ui);
	this.id = "cultGeneralInfo";
	this.name = "Cult information";
	this.type = "info";
	this.points = 30;
};
sects_CultGeneralInfoTask.__name__ = true;
sects_CultGeneralInfoTask.__super__ = sects_Task;
sects_CultGeneralInfoTask.prototype = $extend(sects_Task.prototype,{
	check: function(cult,sect,target) {
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c == cult || !c.isDiscovered[cult.id] || c.isInfoKnown[cult.id]) {
				continue;
			}
			return true;
		}
		return false;
	}
	,complete: function(cult,sect,points) {
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c == cult || !c.isDiscovered[cult.id] || c.isInfoKnown[cult.id]) {
				continue;
			}
			c.isInfoKnown[cult.id] = true;
			var m = "Task completed: Information about " + c.get_fullName() + " gathered.";
			cult.log(m);
			var params = { symbol : "s"};
			cult.logPanel({ id : -1, old : false, type : "cult", text : m, obj : cult, turn : cult.game.turns + 1, params : params == null ? { } : params});
			break;
		}
	}
});
var sects_CultNodeInfoTask = function(g,ui) {
	sects_Task.call(this,g,ui);
	this.id = "cultNodeInfo";
	this.name = "Cult nodes";
	this.type = "info";
	this.isInfinite = true;
	this.points = 0;
};
sects_CultNodeInfoTask.__name__ = true;
sects_CultNodeInfoTask.__super__ = sects_Task;
sects_CultNodeInfoTask.prototype = $extend(sects_Task.prototype,{
	check: function(cult,sect,target) {
		return true;
	}
	,complete: function(cult,sect,points) {
		var _g = 0;
		var _g1 = this.game.cults;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c == cult || !c.isDiscovered[cult.id] || c.isDead) {
				continue;
			}
			var cnt = 0;
			var _g_head = c.nodes.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var n = val;
				if(n.visibility[cult.id] && !n.isKnown[cult.id]) {
					cnt += 20;
					if(cnt >= points) {
						break;
					}
					n.isKnown[cult.id] = true;
					n.update();
				}
			}
			if(cnt >= points) {
				break;
			}
		}
	}
});
var sects_CultResourceInfoTask = function(g,ui) {
	sects_Task.call(this,g,ui);
	this.id = "cultResourceInfo";
	this.name = "Cult resources";
	this.type = "cult";
	this.points = 50;
};
sects_CultResourceInfoTask.__name__ = true;
sects_CultResourceInfoTask.__super__ = sects_Task;
sects_CultResourceInfoTask.prototype = $extend(sects_Task.prototype,{
	check: function(cult,sect,target) {
		var c = target;
		if(cult == c) {
			return false;
		}
		return true;
	}
	,complete: function(cult,sect,points) {
		var c = sect.taskTarget;
		var text = "Task completed:<br>&nbsp;&nbsp;&nbsp;&nbsp;" + c.get_fullName() + " has " + c.power[0] + " (+" + c.powerMod[0] + ") " + UI.powerName(0) + ", " + c.power[1] + " (+" + c.powerMod[1] + ") " + UI.powerName(1) + ", " + c.power[3] + " (+" + c.powerMod[2] + ") " + UI.powerName(2) + ", " + c.power[3] + " (+" + c.powerMod[3] + ") " + UI.powerName(3) + ".";
		cult.log(text);
		var params = { symbol : "s"};
		cult.logPanel({ id : -1, old : false, type : "cult", text : text, obj : cult, turn : cult.game.turns + 1, params : params == null ? { } : params});
		this.ui.alert(text);
	}
});
var sects_CultSabotageRitualTask = function(g,ui) {
	sects_Task.call(this,g,ui);
	this.id = "cultSabotageRitual";
	this.name = "Sabotage ritual";
	this.type = "cult";
	this.isInfinite = true;
	this.points = 0;
	this.level = 1;
};
sects_CultSabotageRitualTask.__name__ = true;
sects_CultSabotageRitualTask.__super__ = sects_Task;
sects_CultSabotageRitualTask.prototype = $extend(sects_Task.prototype,{
	check: function(cult,sect,target) {
		var c = target;
		if(cult == c || !c.isRitual) {
			return false;
		}
		return true;
	}
	,checkFailure: function(sect) {
		var c = sect.taskTarget;
		if(!c.isRitual) {
			return true;
		}
		return false;
	}
	,complete: function(cult,sect,points) {
		var c = sect.taskTarget;
		if(!c.isRitual || c.ritualPoints >= c.ritual.points) {
			return;
		}
		var cnt = 0;
		var pts = 0;
		while(true) {
			cnt += 100;
			if(cnt >= points) {
				break;
			}
			if(Math.random() * 100 > 75) {
				continue;
			}
			c.ritualPoints += 1;
			++pts;
			if(c.ritualPoints >= c.ritual.points) {
				break;
			}
		}
		if(pts > 0) {
			var m = "Ritual of " + c.get_fullName() + " stalled for " + pts + " points.";
			cult.log(m);
			var params = { symbol : "s"};
			cult.logPanel({ id : -1, old : false, type : "cult", text : m, obj : cult, turn : cult.game.turns + 1, params : params == null ? { } : params});
		}
	}
});
var sects_DoNothingTask = function(g,ui) {
	sects_Task.call(this,g,ui);
	this.id = "doNothing";
	this.name = "Do Nothing";
	this.type = "";
	this.isInfinite = true;
	this.points = 0;
};
sects_DoNothingTask.__name__ = true;
sects_DoNothingTask.__super__ = sects_Task;
sects_DoNothingTask.prototype = $extend(sects_Task.prototype,{
	check: function(cult,sect,target) {
		return true;
	}
	,complete: function(cult,sect,points) {
	}
});
var sects_HarvestTask = function(g,ui) {
	sects_Task.call(this,g,ui);
	this.id = "harvest";
	this.name = "Harvest for resources";
	this.type = "none";
	this.points = 100;
	this.level = 1;
};
sects_HarvestTask.__name__ = true;
sects_HarvestTask.__super__ = sects_Task;
sects_HarvestTask.prototype = $extend(sects_Task.prototype,{
	getName: function(sect) {
		return this.name + " (+" + sects_HarvestTask.res[sect.level] + ")";
	}
	,check: function(cult,sect,target) {
		return true;
	}
	,complete: function(cult,sect,points) {
		cult.removeSect(sect.leader,null);
		var text = sect.name + " was harvested for ";
		var val = sects_HarvestTask.res[sect.level];
		var id = Std.random(3);
		if(Std.random(100) < 25) {
			id = 3;
		}
		text += val + " " + UI.powerName(id) + ".";
		cult.power[id] += val;
		cult.log(text);
		var params = { symbol : "s"};
		cult.logPanel({ id : -1, old : false, type : "cult", text : text, obj : cult, turn : cult.game.turns + 1, params : params == null ? { } : params});
		this.ui.alert(text,{ h : Std.parseInt(window.getComputedStyle(window.document.documentElement).getPropertyValue("--alert-window-height-2lines"))});
	}
});
var sects_InvConfuseTask = function(g,ui) {
	sects_Task.call(this,g,ui);
	this.id = "invConfuse";
	this.name = "Confuse investigator";
	this.type = "investigator";
	this.isInfinite = true;
	this.points = 0;
};
sects_InvConfuseTask.__name__ = true;
sects_InvConfuseTask.__super__ = sects_Task;
sects_InvConfuseTask.prototype = $extend(sects_Task.prototype,{
	check: function(cult,sect,target) {
		if(cult.investigator.isHidden) {
			return false;
		}
		return true;
	}
	,checkFailure: function(sect) {
		if(!sect.cult.hasInvestigator || sect.cult.investigator.isHidden) {
			return true;
		}
		return false;
	}
	,complete: function(cult,sect,points) {
		if(!cult.hasInvestigator) {
			return;
		}
	}
});
var sects_InvSacrificeTask = function(g,ui) {
	sects_Task.call(this,g,ui);
	this.id = "invSacrifice";
	this.name = "Sacrifice to investigator";
	this.type = "investigator";
	this.points = 100;
	this.level = 1;
};
sects_InvSacrificeTask.__name__ = true;
sects_InvSacrificeTask.__super__ = sects_Task;
sects_InvSacrificeTask.prototype = $extend(sects_Task.prototype,{
	getName: function(sect) {
		return this.name + " (-" + sects_InvSacrificeTask.will[sect.level] + " WP)";
	}
	,check: function(cult,sect,target) {
		if(cult.investigator.isHidden) {
			return false;
		}
		return true;
	}
	,checkFailure: function(sect) {
		if(!sect.cult.hasInvestigator || sect.cult.investigator.isHidden) {
			return true;
		}
		return false;
	}
	,complete: function(cult,sect,points) {
		if(!cult.hasInvestigator) {
			return;
		}
		cult.investigator.lowerWillpower(sects_InvSacrificeTask.will[this.level]);
		cult.removeSect(sect.leader,"sacrifice");
	}
});
var sects_InvSearchTask = function(g,ui) {
	sects_Task.call(this,g,ui);
	this.id = "invSearch";
	this.name = "Search for investigator";
	this.type = "investigator";
	this.points = 50;
};
sects_InvSearchTask.__name__ = true;
sects_InvSearchTask.__super__ = sects_Task;
sects_InvSearchTask.prototype = $extend(sects_Task.prototype,{
	check: function(cult,sect,target) {
		if(!cult.investigator.isHidden) {
			return false;
		}
		return true;
	}
	,checkFailure: function(sect) {
		if(!sect.cult.hasInvestigator || !sect.cult.investigator.isHidden) {
			return true;
		}
		return false;
	}
	,complete: function(cult,sect,points) {
		if(!cult.hasInvestigator || !cult.investigator.isHidden) {
			return;
		}
		cult.investigator.isHidden = false;
		cult.log("Task completed: Investigator found.");
		var params = { symbol : "s"};
		cult.logPanel({ id : -1, old : false, type : "cult", text : "Task completed: Investigator found.", obj : cult, turn : cult.game.turns + 1, params : params == null ? { } : params});
		this.game.tutorial.play("investigatorFound");
	}
});
var sects_Sect = function(g,uivar,l,c) {
	this.game = g;
	this.ui = uivar;
	this.leader = l;
	this.cult = c;
	this.taskPoints = 0;
	this.taskImportant = false;
	this.size = 10;
	this.level = 0;
	this.name = this.generateName();
	this.isAdvisor = this.cult.options.getBool("sectAdvisor");
};
sects_Sect.__name__ = true;
sects_Sect.prototype = {
	generateName: function() {
		var patterns = [["0"," ","1"],["0"," ","2"],["1"," of ","2"],["0"," ","1"," of ","2"]];
		var pattern = patterns[Std.random(patterns.length)];
		var buf_b = "";
		var _g = 0;
		while(_g < pattern.length) {
			var x = pattern[_g];
			++_g;
			var arr = null;
			if(x == "0") {
				arr = sects_Sect.names0;
			} else if(x == "1") {
				arr = sects_Sect.names1;
			} else if(x == "2") {
				arr = sects_Sect.names2;
			} else {
				buf_b += x == null ? "null" : "" + x;
				continue;
			}
			buf_b += Std.string(arr[Std.random(arr.length)]);
		}
		return buf_b;
	}
	,setTaskByID: function(taskID,target) {
		var _g = 0;
		var _g1 = this.game.sectTasks;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			if(t.id == taskID) {
				this.setTask(t,target);
				return;
			}
		}
	}
	,setTask: function(newTask,target) {
		this.task = newTask;
		this.taskPoints = 0;
		this.taskTarget = target;
	}
	,clearTask: function() {
		this.task = null;
		this.taskTarget = null;
		this.taskPoints = 0;
		this.taskImportant = false;
	}
	,getMaxSize: function() {
		var maxSize = 100;
		if(this.leader.level == 1) {
			maxSize = 500;
		} else if(this.leader.level == 2) {
			maxSize = 1000;
		}
		return maxSize;
	}
	,getGrowth: function() {
		if(this.size < this.getMaxSize()) {
			return 1 + (this.size / sects_Sect.growth[this.leader.level] | 0);
		} else {
			return 0;
		}
	}
	,turn: function() {
		this.size += this.getGrowth();
		if(this.size > this.getMaxSize()) {
			this.size = this.getMaxSize();
		}
		var oldlevel = this.level;
		if(this.size < 100) {
			this.level = 0;
		} else if(this.size < 500) {
			this.level = 1;
		} else if(this.size < 1000) {
			this.level = 2;
		} else {
			this.level = 2;
		}
		if(this.level != oldlevel && !this.cult.isAI) {
			this.ui.log2(this.cult,this.name + " has gained a new level (new tasks available!).",{ type : "sect", symbol : "s"});
			if(this.level == 1) {
				this.game.tutorial.play("sectLevel2");
			}
		}
		if(this.task == null) {
			return;
		}
		this.taskPoints += this.size;
		if(this.taskPoints < this.task.points) {
			return;
		}
		this.task.complete(this.cult,this,this.taskPoints);
		this.taskPoints = 0;
		if(this.leader == null) {
			return;
		}
		if(!this.task.isInfinite) {
			this.clearTask();
			this.game.failSectTasks();
		}
	}
};
var $_;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
Date.__name__ = "Date";
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
js_Boot.__toStr = ({ }).toString;
CustomMenu.difElementInfo = [{ name : "mapWidth", type : "int", title : "Map width", note : "Map width in pixels"},{ name : "mapHeight", type : "int", title : "Map height", note : "Map height in pixels"},{ name : "nodesCount", type : "int", title : "Amount of nodes", note : "Amount of nodes on map"},{ name : "nodeActivationRadius", type : "int", title : "Activation radius", note : "Node activation radius (node can be activated only when the player has an adjacent node in that radius)"},{ name : "numCults", type : "int", title : "Number of cults (2-8)", note : "Number of cults in game"},{ name : "numPlayers", type : "int", title : "Number of human players (1-8)", note : "Number of human players in game"},{ name : "numSummonVirgins", type : "int", title : "Number of virgins for the final ritual", note : "Number of virgins needed to perform final ritual"},{ name : "upgradeChance", type : "float", title : "Max upgrade chance", note : "Higher value raises max upgrade chance"},{ name : "awarenessResource", type : "float", title : "Resource chance awareness mod", note : "Higher value lowers chance of getting resources each turn"},{ name : "awarenessUpgrade", type : "float", title : "Upgrade chance awareness mod", note : "Higher value lowers chance of upgrading followers"},{ name : "awarenessGain", type : "float", title : "Gain follower chance awareness mod", note : "Higher value lowers chance of gaining new followers"},{ name : "investigatorChance", type : "float", title : "Investigator: Appearing chance", note : "Higher value raises chance of investigator appearing"},{ name : "investigatorKill", type : "float", title : "Investigator: Kill follower chance", note : "Higher value raises chance of investigator killing a follower"},{ name : "investigatorWillpower", type : "float", title : "Investigator: Willpower lower chance", note : "Higher value lowers chance of adepts lowering investigator willpower"},{ name : "investigatorTurnVisible", type : "int", title : "Investigator: Turn to become visible", note : "Turn on which new investigator becomes visible"},{ name : "investigatorGainWill", type : "float", title : "Investigator: Chance of gaining will", note : "Higher value raises chance of investigator gaining will"},{ name : "investigatorCultSize", type : "float", title : "Investigator: Cult size mod", note : "Starting investigator willpower - cult size multiplier (less - easier)"},{ name : "maxAwareness", type : "int", title : "AI: Max awareness", note : "Max awareness for AI to have without using adepts"},{ name : "isInfoKnown", type : "bool", title : "Cult info known at start?", note : "Is cult info for all cults known at start?"},{ name : "isOriginKnown", type : "bool", title : "Origin info known at start?", note : "Is origin known for all cults at start?"},{ name : "isDiscovered", type : "bool", title : "Cults discovered at start?", note : "Are cults marked as discovered on start?"}];
DateTools.DAY_SHORT_NAMES = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
DateTools.DAY_NAMES = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
DateTools.MONTH_SHORT_NAMES = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
DateTools.MONTH_NAMES = ["January","February","March","April","May","June","July","August","September","October","November","December"];
Game.powerNames = ["Intimidation","Persuasion","Bribery","Virgins"];
Game.powerShortNames = ["I","P","B","V"];
Game.followerNames = ["Neophyte","Adept","Priest"];
Game.powerConversionCost = [2,2,2,1];
Game.willPowerCost = 2;
Game.version = "v6";
Game.followerLevels = 3;
Game.numPowers = 3;
Game.upgradeCost = 3;
Game.isDebug = false;
Game.debugTime = false;
Game.debugVis = false;
Game.debugNear = false;
Game.debugAI = false;
Game.debugDirector = false;
Game.mapVisible = false;
GenName.namesMale = [["Austin","Calvin","Carl","Clarence","Donald","Dwight","Ed","Kevin","Lester","Mark","Oscar","Samuel","Spencer","Tom","Virgil"],["Adam","Alan","Arthur","Brett","Damien","David","Frank","James","John","Michael","Neil","Patrick","Paul","Randolph","Robert","Scott"],["Armand","Bernard","Claude","Emile","Gaston","Gerard","Henri","Jacques","Jean","Leon","Louis","Marc","Marcel","Pierre","Rene"],["Dieter","Franz","Gerhard","Gunter","Hans","Jurgen","Klaus","Manfred","Matthias","Otto","Rudi","Siegfried","Stefan","Werner","Wolfgang"],["Akinori","Isao","Jungo","Hideo","Kenji","Masaharu","Masanori","Naohiro","Shigeo","Shigeru","Shuji","Tatsuo","Toshio","Yasuaki","Yataka","Yuzo"],["Anatoly","Andrei","Boris","Dmitriy","Gennadiy","Grigoriy","Igor","Ivan","Leonid","Mikhail","Nikolai","Sergei","Victor","Vladimir","Yuri"],["Aarav","Aarush","Advait","Advik","Anay","Ansh","Arjun","Atharv","Ayaan","Ayansh","Dhruv","Ishaan","Jayden","Kabir","Pranav","Rayan","Reyansh","Rudransh","Saathvik","Shaurya","Vedant","Vihaan","Yuvaan"],["Bai","Bo","Chao","Cheng","Chi","Chongkun","Chuanli","Chung","Da","Delun","Deming","Dingbang","Dong","Duyi","Enlai","Feng","Geming","Guang","Gui","Guowei","Huang","Hui","Hulin","Hung","Huojin","Jiang","Kang","Lei","Liang","Liko","Liu","Liwei","Longwei","Mingli","Nianzu","Ping","Qi","Qiang","Quan","Shen","Shing","Shoushan","Siyu","Tengfei","Wang","Wei","Wencheng","Wuzhou","Xing","Xiu","Xue","Yang","Yaochuan","Yaoting","Yaozu","Yi","Yuanjun","Yunxu","Yusheng","Zedong","Zhen","Zhong"]];
GenName.namesFemale = [["Addison","Adeline","Alexa","Allison","Ariana","Aubrey","Audrey","Avery","Barbara","Brooklyn","Caroline","Catherine","Claire","Evelyn","Hailey","Hannah","Harper","Hazel","Kennedy","Leah","Lily","Lucy","Madelyn","Madison","Nora","Patricia","Piper","Samantha","Sarah","Sigourney","Sophia","Stella","Victoria","Violet"],["Abigail","Alice","Amelia","Andrea","Ava","Daisy","Eleanor","Elizabeth","Ella","Emily","Evelyn","Evie","Florence","Grace","Harriet","Helen","Holly","Jane","Jessica","Lily","Lucy","Maria","Olivia","Phoebe","Sarah","Scarlett","Sophie"],["Adele","Camille","Charlotte","Chloe","Danielle","Eva","Ines","Jacqueline","Jeanne","Juliette","Lea","Lina","Louise","Marielle","Micheline","Sofia","Sylvie","Victoria"],["Christel","Clara","Emilia","Emma","Frieda","Gudrun","Hannah","Helga","Johanna","Karin","Laura","Leni","Lina","Luisa","Marie","Mathilda","Nele","Uta"],["Akari","Aoi","Haruka","Hina","Hinata","Honoka","Koharu","Mariko","Mei","Michiko","Mio","Miyu","Momoka","Rin","Rio","Saki","Sata","Sumie","Yoko","Yui","Yume","Yuna"],["Alina","Alyona","Anastasia","Anna","Ekaterina","Elena","Elizaveta","Galina","Irina","Kristina","Ksenia","Lyudmila","Margarita","Natalya","Olga","Polina","Tatyana","Valeria","Varvara","Veronika","Viktoria","Yulia","Zhanna"],["Aaradhya","Aarohi","Aarya","Aditi","Advika","Ahana","Anaya","Anika","Anvi","Avani","Ayesha","Diya","Isha","Meera","Myra","Navya","Pari","Pihu","Prisha","Priya","Riddhi","Saanvi","Samaira","Siya","Sri","Swara"],["An","Bik","Biyu","Bo","Chenguang","Cuifen","Daiyu","Dandan","Dongmei","Far","Fenfang","Fung","Howin","Hua","Jiayi","Jie","Jinghua","Kwong","Lan","Li","Ling","Liqiu","Luli","Mei","Ning","Niu","Qing","Qiu","Rong","Rou","Ruiling","Ruolan","Shaoqing","Shihong","Shu","Song","Suyin","Ting","Ushi","Weici","Wen","Xia","Xifeng","Xiu","Xueman","Yanmei","Yanyu","Ying","Yuan","Yue","Yuming","Yun","Yusheng","Zhenzhen","Zhilan","Zhu"]];
GenName.surnames = [["Bradley","Bryant","Carr","Crossett","Dodge","Gallagher","Homburger","Horton","Hudson","Johnson","Kemp","King","McNeil","Miller","Mitchell","Nash","Stephens","Stoddard","Thompson","Webb"],["Bailey","Blake","Carter","Davies","Day","Evans","Hill","Jones","Jonlan","Martin","Parker","Pearce","Reynolds","Robinson","Sharpe","Smith","Stewart","Taylor","Watson","White","Wright"],["Bouissou","Bouton","Buchard","Coicaud","Collignon","Cuvelier","Dagallier","Dreyfus","Dujardin","Gaudin","Gautier","Gressier","Guerin","Laroyenne","Lecointe","Lefevre","Luget","Marcelle","Pecheux","Revenu"],["Berger","Brehme","Esser","Faerber","Geisler","Gunkel","Hafner","Heinsch","Keller","Krause","Mederow","Meyer","Richter","Schultz","Seidler","Steinbach","Ulbricht","Unger","Vogel","Zander"],["Akiyama","Fujimoto","Ishii","Iwahara","Iwasaki","Kojima","Koyama","Matsumara","Morita","Noguchi","Okabe","Okamoto","Sato","Shimaoka","Shoji","Tanida","Tanikawa","Yamanaka","Yamashita","Yamazaki"],["Andryanov","Belov","Chukarin","Gorokhov","Kolotov","Korkin","Likhachev","Maleev","Mikhailov","Petrov","Razuvaev","Romanov","Samchenko","Scharov","Shadrin","Shalimov","Torbin","Voronin","Yakubchik","Zhdanov"],["Acharya","Agarwal","Ahluwalia","Ahuja","Amin","Anand","Apte","Arya","Babu","Bakshi","Banerjee","Basu","Bedi","Bhatt","Burman","Chadha","Chakrabarti","Chawla","Chopra","Chowdhury","Dara","Datta","Deshpande","Dewan","Khatri","Kohli","Laghari","Lal","Patel","Varma"],["Chang","Chao","Chou","Chu","Han","Hsiao","Hsieh","Hsu","Hu","I","Kang","Kung","Kuo","Lei","Lo","Lung","Ma","Meng","Mo","Shen","Su","Sun","Tai","Ting","Tseng","Tsou","Tuan","Tung","Wei","Wong","Wu","Yao","Yen","Zhuang"]];
MapUI.textToIndex = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	if(__map_reserved["?"] != null) {
		_g.setReserved("?",0);
	} else {
		_g.h["?"] = 0;
	}
	if(__map_reserved["S"] != null) {
		_g.setReserved("S",1);
	} else {
		_g.h["S"] = 1;
	}
	if(__map_reserved["1"] != null) {
		_g.setReserved("1",2);
	} else {
		_g.h["1"] = 2;
	}
	if(__map_reserved["2"] != null) {
		_g.setReserved("2",3);
	} else {
		_g.h["2"] = 3;
	}
	if(__map_reserved["3"] != null) {
		_g.setReserved("3",4);
	} else {
		_g.h["3"] = 4;
	}
	if(__map_reserved["-"] != null) {
		_g.setReserved("-",5);
	} else {
		_g.h["-"] = 5;
	}
	$r = _g;
	return $r;
}(this));
MultiplayerMenu.difElementInfo = [{ name : "numCults", type : "int", title : "Number of cults (2-8)", params : null},{ name : "numPlayers", type : "int", title : "Number of human players (1-8)", params : null},{ name : "difficulty", type : "select", title : "Game difficulty", params : ["Easy","Normal","Hard"]},{ name : "mapSize", type : "select", title : "Map size", params : ["Small","Medium","Large","Huge"]}];
Node.jobs = ["Government official","Corporate worker","University professor","Army officer","Scientist","Politician","Media person"];
OptionsMenu.elementInfo = [{ name : "mapAdvancedMode", type : "bool", title : "Advanced map mode", note : "Displays additional node information on map"},{ name : "logPanelSkipSects", type : "bool", title : "No sect messages in log panel", note : "Will not show sect messages in log panel"},{ name : "sectAdvisor", type : "bool", title : "Sect advisor", note : "Sect advisor will automatically give tasks to sects depending on the situation", y : 64},{ name : "fullscreen", type : "bool", title : "Fullscreen", note : "Enable or disable fullscreen mode"}];
Static.difficulty = [{ level : 0, mapWidth : 780, mapHeight : 580, nodesCount : 100, nodeActivationRadius : 101, numCults : 3, numPlayers : 1, numSummonVirgins : 6, upgradeChance : 1.10, awarenessResource : 1.25, awarenessUpgrade : 0.75, awarenessGain : 0.75, investigatorChance : 0.50, investigatorKill : 0.75, investigatorWillpower : 0.75, investigatorTurnVisible : 0, investigatorGainWill : 0.50, investigatorCultSize : 0.05, maxAwareness : 10, isInfoKnown : true, isOriginKnown : true, isDiscovered : true},{ level : 1, mapWidth : 780, mapHeight : 580, nodesCount : 100, nodeActivationRadius : 101, numCults : 4, numPlayers : 1, numSummonVirgins : 9, upgradeChance : 1.0, awarenessResource : 1.5, awarenessUpgrade : 1.0, awarenessGain : 1.0, investigatorChance : 1.0, investigatorKill : 1.0, investigatorWillpower : 1.0, investigatorTurnVisible : 10, investigatorGainWill : 0.75, investigatorCultSize : 0.1, maxAwareness : 5, isInfoKnown : false, isOriginKnown : false, isDiscovered : false},{ level : 2, mapWidth : 780, mapHeight : 580, nodesCount : 100, nodeActivationRadius : 101, numCults : 4, numPlayers : 1, numSummonVirgins : 9, upgradeChance : 0.90, awarenessResource : 1.75, awarenessUpgrade : 1.25, awarenessGain : 1.25, investigatorChance : 1.25, investigatorKill : 1.25, investigatorWillpower : 1.25, investigatorTurnVisible : 2000, investigatorGainWill : 1.0, investigatorCultSize : 0.15, maxAwareness : 5, isInfoKnown : false, isOriginKnown : false, isDiscovered : false},{ level : -1, mapWidth : 780, mapHeight : 580, nodesCount : 100, nodeActivationRadius : 101, numCults : 4, numPlayers : 2, numSummonVirgins : 9, upgradeChance : 1.0, awarenessResource : 1.5, awarenessUpgrade : 1.0, awarenessGain : 1.0, investigatorChance : 1.0, investigatorKill : 1.0, investigatorWillpower : 1.0, investigatorTurnVisible : 10, investigatorGainWill : 0.75, investigatorCultSize : 0.1, maxAwareness : 5, isInfoKnown : false, isOriginKnown : false, isDiscovered : false}];
Static.cults = [{ name : "Cult&nbsp;of&nbsp;Elder&nbsp;God", note : "The cult still lives.", longNote : "At the dawn of humanity the great old ones told their secrets in dreams to the first men, who formed a cult which had never died... Hidden in distant and dark places of the world, waiting for the day when the stars will be right again and the mighty Elder God will rise from his slumber under the deep waters to bring the earth beneath his sway once more.", summonStart : "", summonFinish : "", summonFail : ""},{ name : "Pharaonic&nbsp;Slumber", note : "A group that wants to put the entire world to sleep, feeding on the nightmares of the dreamers.", longNote : "Abhumans from a dark dimension close to ours came to Earth thousands of years ago, trading their magics and technology with the Egyptians for control of their people's minds when they slept, for they fed upon nightmares. With the secret help of the Roman Empire, the Egyptians drove the abhumans into hiding. But they have returned, and their goal has grown with time: the permanent slumber of the world.", summonStart : "As the Pharaonic Slumber's power grows, the world enters a state of controlled drowsiness. People go to bed earlier and sleep later, their dreams plagued with thoughts of sweeping sands and dark figures. Short naps at work become almost commonplace, and as the abhumans feed upon the dreaming energies of the world, everyone feels less and less energetic. All the more reason to take a bit of a rest...", summonFinish : "The world drifts off to sleep, some even slumping to the sidewalk where they were just walking or barely managing to bring their vehicles to a stop. The abhumans come out in force, walking amongst the dreaming populace, feeding hungrily upon the horrid dreams foisted upon them by the dark magics. A few humans manage to keep themselves awake a bit longer on massive doses of amphetamines, but soon they too crash into the darkness of eternal slumber, screaming into unconsciousness as they see the burning red eyes of those who've come to consume their thoughts.", summonFail : "People shake off the dozing state that had captured them. Sales of coffee and cola rocket temporarily, an odd spike that intrigues many commentators, and for a moment humanity is more awake than it has ever been before. Soon, however, old habits return, and some are still plagued by dreams of windswept deserts they have never before seen and cloaked figures that move in a way that somehow feels inhuman, dreams that feel more real than reality."},{ name : "Blooded&nbsp;Mask", note : "A group devoted to ripping away the masks people wear and revealing the insane reality beyond.", longNote : "Those who peer too long into the Abyss find that it stares back at them, and the Blooded Mask has long gazed into the ineffable world beyond our own. Affiliated with no Elder God, or perhaps all of them, the Blooded Mask longs to show humanity the brutal truths that hide behind the consensual reality. The truths drive those who see them insane, filling them with a desire to show others as well, and the Blooded Mask are the original converts.", summonStart : "A rash of cases of schizophrenia and paranoid delusions becomes an epidemic.  World health organizations struggle to understand environmental factors behind the increasing numbers of psychotic breaks and irrational behaviour across the world, unaware of the rituals the Blooded Mask are enacting.  The only clue is an increased incidence of individuals trying to claw their eyes out, often babbling about seeing <i>the truth</i> better without them.", summonFinish : "Even the most stable individuals become gripped by the desire to see beyond the veil. Plucking their eyes out, almost as one, humanity peers out of bloody sockets into the screaming void of alien truth that had, until then, been hidden to most. The Bloody Veil's incantations brought to their climax, the world becomes a madhouse of screaming blind horror, people stumbling through living nightmares in colours their minds were never meant to comprehend, groping past those others wandering in the same strange geometries.", summonFail : "The outbreak of madness draws to a close, the circumstances at its end as mysterious as when it began. Sanity returns to some of those who saw the underlying truth, but those who blinded themselves are relegated to sanitariums around the world, their screaming reverberating in the halls of the buildings, unable to stop seeing the horrifying ur-reality. A small number of painters attempt to incorporate the colours they saw in their madness into their work, and the epileptic seizures their paintings evoke cause the black ops divisions of the world's governments to destroy all evidence of their work."},{ name : "Universal&nbsp;Lambda", note : "Programmers who want to turn humanity into a vast processing machine.", longNote : "In the early seventies, a secret government project uncovered the changes necessary to turn any human brain into an efficient, soulless computer.  Little did the project know that it had been subverted by a dark cult. The Universal Lambda works to refine that now-defunct project's results: the turning of every human being into cogs of a huge machine, a distributed network for the vast living intellect of the Elder God.", summonStart : "The Universal Lambda's cybermantic machinations begin to influence the entire world.  People start to walk in unconscious lockstep down the streets; crime and accident rates drop as the rituals rewire minds to be more and more regimented.  People make fewer choices, locking themselves into patterns without realizing the steady loss of free will.", summonFinish : "Their rituals complete, the Universal Lambda turns the world into a well-oiled machine. Bodies still move around, taking part in the same rote behavior they did before, but the minds of the populace are gone. Instead of thinking independent thoughts, humanity's brains run the code that allows The Machine to run in our dimension. The tiny flickers of free will brought upon by every birth are quickly consumed by the overwhelming cybermantic magics enveloping the world; all are just parts of the giant soulless entity... ", summonFail : "The eerily constant behavior of humanity slowly returns to its regular froth of chaos. People still occasionally slip into the robotic state they exhibited mere days before, but the rising rate of accidents and deaths heralds the return of free will, for better or worse."},{ name : "Drowned", note : "Vengeful spirits determined to drown the rest of the world.", longNote : "Over the millennia, hundreds of thousands of people have drowned in the oceans, lakes, and rivers of the world. Most of them pass peacefully into oblivion, but some linger, warped by the experience of their death. Over time, those who remain have gathered together in an undead cabal. They want the rest of the world to join them in their watery graves, and will stop at nothing to make it happen.", summonStart : "It begins to rain. A slow drizzle at first, the entire world is soon enveloped in an unending thunderstorm, water pouring from the heavens without an end in sight. Low-lying regions begin to flood, and it is only a matter of time before even the highest ground is inundated.", summonFinish : "The heavy rains turn torrential.  The sea level rises inexorably as humanity crowds further and further up into the mountains.  Still the rains come, still the waters climb.  Every death in the water adds to the power of the Drowned, the force of the neverending rain.  Many take to boats in an attempt to survive on the surface of the sea, only to find that no ship remains seaworthy; leaks spring up in unlikely places, and soon every vessel succumbs to the inexorable pull of the dark depths below.  The last gasp of humanity is a doomed man standing on the peak of Everest, and then he goes under once. Twice. He is gone.", summonFail : "The rains slacken, first to a light patter, then a drizzle, then nothing but the usual patterns of storms and showers. Commentators argue that the excess water had to come from somewhere, but within days everything seems to have returned to equilibrium, the ghost rains drying up into nothing.  Scientists are at a loss to explain the phenomenon, but the rest of the world returns to its routine, although many glance at the sky whenever a cloud darkens the day, worried that it might once again begin to rain forever."},{ name : "Manipulators", note : "Powerful magicians who wish to enslave humanity.", longNote : "For centuries, men in power have desired the ability to make their subjects obey their every whim. Some have used force, or fear, but none have been completely successful. A group of powerful male magicians, many of whom control powerful multinational corporations, are determined to succeed where others have failed.  Through the use of mind-manipulation magic, memetic manipulation, and subtle influence in world governments, they plan to make every other man, woman, and child on the planet their slaves, forced into fulfilling the Manipulators' dark desires.", summonStart : "The Manipulators start their ultimate ritual with a slow but insidious assault on the psyches of the world, using traditional advertising techniques combined with subtle dark magics.  Much of their work is couched in the comforting form of mass media, convincing people that the old inhibited days are over, that a new dawn of peace, prosperity, and happiness is on the horizon, subtly hinting that a chosen few will be the ones to lead humanity into the new golden age.  Many are skeptical, but many more are taken in by the Manipulators' careful schemes, as the magics work their way on the minds of the converted and unconverted alike.", summonFinish : "The Manipulators' control of the world becomes more and more overt, their supposedly-benign stewardship turning into outright worship by the masses. Their magics turn support into adulation, appreciation into unfettered desire; the world wants, needs to fulfill their every whim, no matter the consequence. People of all genders and ages disappear into the gleaming palaces, their bodies and minds used for unmentionable new rituals. The diversity of humanity is now nothing more than a living, breathing mass of clay for the Manipulators to sculpt as they desire. And their desires are manifold indeed.", summonFail : "What at first seemed like the genuine rise of a new era of freedom and prosperity turns sour, many of its proponents discovered to be frauds and freaks.  The Manipulators themselves stay behind the scenes, protected by layers of misdirection and human shields, but the effects of their manipulations begin to fade.  People once again assert contrary views with candor; for a moment, they view the mass media with a genuinely critical eye.  Then the time passes, advertisements and packaged views reasserting their mundane control on the opinions, just another day in this modern life."},{ name : "The Frozen Dream", note : "A group of ice demons that want to freeze the world. ", longNote : "Led by unholy denizens of frozen wastes, The Frozen Dream works to turn the world into an eternal winter horrorland, full of ice demons and frosthounds cavorting in the terrible chill. What little can survive in the icy bleakness will be hunted for sport. ", summonStart : "As The Frozen Dream begins their dark rituals, temperatures across the world begin to drop. Winter has become bitterly frigid, spring and fall too cold for the plants, and summer a wan shadow of its former self. Weather patterns spiral out of control, and food crops wither and die. ", summonFinish : "Their dark ritual complete, The Frozen Dream's grasp upon the Earth becomes stronger. The biting cold becomes unbearable, freezing and shattering plants and animals alike still on the surface. What little humanity remains is ensconced deep underground, but the unnatural chill manages to penetrate even those bastions, slowly but surely. It is only a matter of time before the thin flame of natural life is extinguished by the icy winds that blow across the planet. ", summonFail : "The unnatural chill of recent days begins to fade, the world scrambling to repair what damage can be fixed. Many still shiver uncontrollably when a gust of cool air blows past them, a psychic remnant of the grasp The Frozen Dream nearly had upon the Earth."},{ name : "The Slake", note : "Emotional vampires who feed on ecstasy and horror.", longNote : "Legends passed down for generations speak of vampires, those who consume the blood of mankind. Little do most know that those stories contain the dim shine of truth: twisted creatures among humanity, drinking in strong emotion and leaving shattered husks. With the world ripe for the plucking, the Slake want nothing more than to turn it all into an eternal feeding ground.", summonStart : "The Slake begin to draw on their stores of distilled emotions, slowly drawing the world into a heightened sense of existence. Petty disputes flare into armed conflicts, teetering towards full-fledged wars; long-hidden passions and desires erupt into a re-flowering of hedonism. On the edges of it all, the vampires drink and drink, powering their dark magics ever further...", summonFinish : "Society collapses into an orgy of violence and ecstasy. Nation-states collapse as they destroy each other in terrible attacks and counterattacks, while those back home fall into reckless passion, destroying relationships and souls alike as the Slake consume it all. They leave only a small number of chattel alive, to procreate and destroy as they drain them, one by one, until the end of time.", summonFail : "The strange passions that had gripped the world fade like a bad dream, the world shaking off the heightened sense of everything with little more than whispers of concern. A wild season, nothing more, the media proclaims, a self-fulfilling prophecy. The Slake retreat for a while, to gather their powers once again for another attempt at goading the world into providing the emotions they crave."}];
Static.rituals = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	{
		var value = { id : "summoning", name : "Final Ritual", virgins : 9, priests : 3, points : 10, note : "Upon completion this cult will reign over the world unchallenged."};
		if(__map_reserved["summoning"] != null) {
			_g.setReserved("summoning",value);
		} else {
			_g.h["summoning"] = value;
		}
	}
	{
		var value1 = { id : "unveiling", name : "Ritual of Unveiling", virgins : 5, priests : 1, points : 3, note : "The ritual of Unveiling will show all cult origins upon completion. Requires 1 priest and 5 virgins to perform."};
		if(__map_reserved["unveiling"] != null) {
			_g.setReserved("unveiling",value1);
		} else {
			_g.h["unveiling"] = value1;
		}
	}
	$r = _g;
	return $r;
}(this));
UI.classicModeVars = { cultColors : ["#00B400","#2F43FD","#B400AE","#B4AE00","#0988ff","#609612","#a85700","bb000b"], lineColors : ["#55dd55","#2727D7","#E052CA","#D8E151","#0988ff","#609612","#a85700","#990009"], nodePixelColors : [[85,221,85],[39,39,215],[224,82,202],[216,225,81],[9,136,255],[96,150,18],[168,87,0],[153,0,9]], nodeNeutralPixelColors : [120,120,120], markerWidth : 15, markerHeight : 15, scaleFactor : 1.0};
UI.modernModeVars = { cultColors : ["#009933","#FF3366","#009999","#ff9900","#FF3300","#3300CC","#660099","#330000","#999999"], lineColors : ["#009933","#FF3366","#009999","#ff9900","#FF3300","#3300CC","#660099","#330000"], nodePixelColors : [[0,153,51],[255,51,102],[0,153,153],[255,151,0],[255,51,0],[51,60,254],[142,0,193],[51,0,0]], nodeNeutralPixelColors : [150,150,150], markerWidth : 60, markerHeight : 60, scaleFactor : 4.0};
UI.modernPowerImages = ["power-intimidation","power-persuasion","power-bribery"];
UI.modernGeneratorColors = [null,[null,"b0","d0"],null,[null,"a0","c0"],[null,"a0","c0"],null,null,null,[null,"70","c0"]];
UI.modernMode = true;
UI.classicMode = false;
UI.vars = UI.modernModeVars;
UI.maxSaves = 5;
Status.tipPowers = [UI.powerName(0) + " is needed to gain new followers.",UI.powerName(1) + " is needed to gain new followers.",UI.powerName(2) + " is needed to gain new followers.",UI.powerName(3) + " are gathered by your neophytes.<br>" + "They are needed for rituals to upgrade your<br>followers " + "and also for the final ritual of summoning."];
Status.tipConvert = "Cost to convert to ";
Status.tipUpgrade = ["To gain an adept you need " + Game.upgradeCost + " neophytes and 1 virgin.","To gain a priest you need " + Game.upgradeCost + " adepts and 2 virgins.",""];
Status.tipFollowers = ["Neophytes can find some virgins if they're lucky.","Adepts can lower society awareness and investigator's willpower.",""];
Status.tipTurns = "Shows the number of turns passed from the start.";
Status.tipAwareness = "Shows how much human society is aware of the cult.<br>" + "<li>The greater awareness is the harder it is to do anything:<br>" + "gain new followers, resources or make rituals.<br> " + "<li>Adepts can lower the society awareness using resources.<br>" + "<li>The more adepts you have the more you can lower awareness each turn." + "<li>With very low awareness the cult can stay undetected by an investigator.";
Status.tipLowerAwareness = "Your adepts can use resources to lower society awareness.";
Status.tipLowerWillpower = "Your adepts can use resources to lower willpower of an investigator.<br>Cost: ";
Status.tipEndTurn = "Click to end current turn (or press <span class=shadow style=\"color:white\">E</span>).";
Status.tipMainMenu = "Click to open main menu (or press <span class=shadow style=\"color:white\">ESC</span>).";
Tutorial.strings = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	{
		var value = ["Greetings. You are playing a game about nefarious cults vying for world domination (or destruction). You are controlling one of these cults.","Your cult consists of followers who have three different categories. You can see their numbers on the left in the status window. The map window shows the icons that represent your followers and persons of interest.","At the beginning of the game, you only have one follower. This is the origin of your cult. To grow your cult you need to gain new followers by clicking their icons on the map.","Press the End Turn button in the status window to continue."];
		if(__map_reserved["start"] != null) {
			_g.setReserved("start",value);
		} else {
			_g.h["start"] = value;
		}
	}
	{
		var value1 = ["To gain followers you need to spend common resources. You can see all your resources in the status window on the left.","There are three common resources in the game and one special. " + UI.powerName(0) + ", " + UI.powerName(1) + " and " + UI.powerName(2) + " are common resources and are used directly to gain new followers.","You can convert any common resource to another one at a 2:1 ratio. There is also a special resource - " + UI.powerName(3) + ". You will need " + UI.powerName(3) + " for rituals and you can convert them to common resources at a 1:1 ratio.","Common resources are produced by special \"generator\" followers. They have a thicker outline around their icons on the map. " + UI.powerName(3) + " are obtained by your neophytes.","Your cult origin is a generator. The tooltip for the follower icon shows its information including the resource it generates. On each new turn, all your generators will produce resources.","The resource icon on top of the map icon shows which resource you need to gain that follower. Try to gain a new follower by clicking on their icon. If you do not have enough resources of that type, convert them."];
		if(__map_reserved["endTurn"] != null) {
			_g.setReserved("endTurn",value1);
		} else {
			_g.h["endTurn"] = value1;
		}
	}
	{
		var value2 = ["Each time you gain a new follower, one or more lines will appear from them to adjacent followers.","These lines symbolize a direct connection from one follower to another.","Resource generators can be protected by having three separate connections to them from your other followers. Common followers cannot be protected.","Protect your origin by gaining three followers adjacent to it."];
		if(__map_reserved["gainNode"] != null) {
			_g.setReserved("gainNode",value2);
		} else {
			_g.h["gainNode"] = value2;
		}
	}
	{
		var value3 = ["Good, your origin is now protected. It means that before your opponents can attack it they will have to first take over the followers around until the origin has less than three connections to it.","If the cult loses its origin, it will become paralyzed for some time. Try to keep your origin protected.","Continue expanding your cult."];
		if(__map_reserved["originProtected"] != null) {
			_g.setReserved("originProtected",value3);
		} else {
			_g.h["originProtected"] = value3;
		}
	}
	{
		var value4 = ["Oh, joy! One of your followers has gained their own little sect. Sects are very useful to handle menial tasks like gathering information about your opponents.","They can also help you find the next investigator when they inevitably appear and confuse them. You can check out your sects in the sects window.","By default, the sect tasks are handled automatically with the help of an AI advisor. They grow by themselves and new tasks will appear upon reaching level 2.","A sect will be disbanded if its puppeteer is lost."];
		if(__map_reserved["gainSect"] != null) {
			_g.setReserved("gainSect",value4);
		} else {
			_g.h["gainSect"] = value4;
		}
	}
	{
		var value5 = ["Each time you gain a new follower by spending resources, public awareness of your cult rises. You can see it in the status window. ","The higher it is, the more difficult it is to gain new followers or upgrade them. To lower awareness you need adepts. You can gain adepts by upgrading your neophyte followers in a ritual using " + UI.powerName(3) + ".","Upgrading is done by pressing the + button near the neophytes amount in the status window. The button becomes visible if you have at least 3 neophytes and 1 virgin.","Try to gain an adept."];
		if(__map_reserved["awareness"] != null) {
			_g.setReserved("awareness",value5);
		} else {
			_g.h["awareness"] = value5;
		}
	}
	{
		var value6 = ["You have gained your first adept. You can now spend common resources to lower public awareness. Any single adept can only be used once per turn to do it.","To use an adept, click on A button near the common resource name in the status window on the left.","Coincidentally, you've opened yourself up to the potential investigators. There's a chance that an intrepid investigator will learn about the existence of your cult.","To minimize that chance, keep the awareness low."];
		if(__map_reserved["gainAdept"] != null) {
			_g.setReserved("gainAdept",value6);
		} else {
			_g.h["gainAdept"] = value6;
		}
	}
	{
		var value7 = ["Oh, my. It looks like you've gained the attention of one of those pesky little investigators. You can see the investigator information in the cults window.","The investigator has a level and willpower. Each turn they will try to attack the number of your followers equal to their level.","The investigator's willpower is their desire to work against your cult. You need to lower it to zero as quickly as possible. When it goes down to zero, they disappear.","However, currently, the investigator is hidden and you cannot attack them. One of your sects is working on finding them.","In the meantime try to keep awareness close to zero. That will help with protecting your followers from investigator attacks."];
		if(__map_reserved["investigator"] != null) {
			_g.setReserved("investigator",value7);
		} else {
			_g.h["investigator"] = value7;
		}
	}
	{
		var value8 = ["One of your sects has managed to find out where the investigator is hiding.","Now your adepts can use common resources to lower their willpower. You do have multiple adepts, right?"];
		if(__map_reserved["investigatorFound"] != null) {
			_g.setReserved("investigatorFound",value8);
		} else {
			_g.h["investigatorFound"] = value8;
		}
	}
	{
		var value9 = ["Finally. The investigator has lost the will to go on fighting and is out of the cosmic equation. You are free to continue.","That is, until the next one appears. But we already know how to deal with them, correct?"];
		if(__map_reserved["investigatorDead"] != null) {
			_g.setReserved("investigatorDead",value9);
		} else {
			_g.h["investigatorDead"] = value9;
		}
	}
	{
		var value10 = ["One of your sects has managed to grow up to level 2. Now it will try to sabotage the rituals of your opponents when necessary. And it can be sacrificed to stop an investigator or harvested for resources.","Sacrificing the sect to stop an investigator will significantly reduce their willpower but will destroy the sect in the process. Not to worry, the puppeteer will create a new one to replace it.","Harvesting the sect is also a one-time operation. In this case, your cult will acquire a stash of resources destroying it in the process. Of course, you can leave the sect alone, but where's the fun in that?"];
		if(__map_reserved["sectLevel2"] != null) {
			_g.setReserved("sectLevel2",value10);
		} else {
			_g.h["sectLevel2"] = value10;
		}
	}
	{
		var value11 = ["You have discovered one of the other cults I've been talking about. They are ruthless, psychopathic and willing to bring the end of the world as we know it. Just like you are.","Your sects will first automatically gather information about the cult size and then will go on to research every new cult follower you uncover.","Leave your sects to gather information and plan for eventual hostilities. After all, only one cult will be the one to lead the Earth into a glorious new age (hopefully, yours)."];
		if(__map_reserved["discoverCult"] != null) {
			_g.setReserved("discoverCult",value11);
		} else {
			_g.h["discoverCult"] = value11;
		}
	}
	{
		var value12 = ["You have discovered one of the other cults I've been talking about. They are ruthless, psychopathic and willing to bring the end of the world as we know it. Just like you are.","You cannot get any information about other cults unless you have sects. They will automatically gather information about the cult size and then will go on to research every new cult follower you uncover.","Expand carefully to at least 4 followers to get a sect and plan for eventual hostilities. After all, only one cult will be the one to lead the Earth into a glorious new age (hopefully, yours)."];
		if(__map_reserved["discoverCultNoSects"] != null) {
			_g.setReserved("discoverCultNoSects",value12);
		} else {
			_g.h["discoverCultNoSects"] = value12;
		}
	}
	{
		var value13 = ["Tsk, tsk, tsk. It seems that your cult has lost its origin before I could teach you the basics of world domination. The Elder God will be very disappointed.","You cannot gain any new followers while your cult is paralyzed. Wait for now and reflect on what went wrong. If your cult manages to survive for some time, you will gain a new origin."];
		if(__map_reserved["cultParalyzed"] != null) {
			_g.setReserved("cultParalyzed",value13);
		} else {
			_g.h["cultParalyzed"] = value13;
		}
	}
	{
		var value14 = ["You have 3 adepts now. That and 2 " + UI.powerName(3) + " are enough to upgrade one of them into a priest. Whether to do that right now is up to you, of course, but only priests can perform rituals.","  You will need 3 priests and a sizable amount of " + UI.powerName(3) + " to start summoning the Elder God. If the summoning is a success, you will win the game."];
		if(__map_reserved["gain3Adepts"] != null) {
			_g.setReserved("gain3Adepts",value14);
		} else {
			_g.h["gain3Adepts"] = value14;
		}
	}
	{
		var value15 = ["Praise the Elder God! You have a priest now. A single priest and 5 " + UI.powerName(3) + " is enough to perform the ritual of Unveiling. This ritual will show where all other cult origins are located on the map.","During the ritual, each priest contributes a point to its execution. You need a fixed amount of points to finish the ritual. That means the more priests you have, the quicker you will complete it.","You can see the ritual progress in the cults information window.","Don't forget that public awareness lowers the chance of success. It's a good idea to keep it low for the moment when the ritual finishes."];
		if(__map_reserved["gainPriest"] != null) {
			_g.setReserved("gainPriest",value15);
		} else {
			_g.h["gainPriest"] = value15;
		}
	}
	{
		var value16 = ["Oh, bother. One of your enemies has started performing their Final Ritual. If they are successful, you will lose the game.","If you have any sects of level 2 and higher, they are already focused on sabotaging it (unless they're busy with the investigator).","To stall the ritual even more, you can try to gain their priests if you have access to them on the map. If the enemy cult loses its origin, the ritual will be stopped completely."];
		if(__map_reserved["enemyFinalRitual"] != null) {
			_g.setReserved("enemyFinalRitual",value16);
		} else {
			_g.h["enemyFinalRitual"] = value16;
		}
	}
	$r = _g;
	return $r;
}(this));
UINode.imageKeys = { c : [0,17], cg : [19,21], cgp : [42,21], o : [65,25], op : [92,25], neutral : [125,17], neutralg : [144,21]};
UINode.jobInfo = [{ img : "char-official-male.png", x : 3, y : 0, w : 52, h : 52},{ img : "char-official-female.png", x : 2, y : 0, w : 52, h : 52},{ img : "char-corporate-male.png", x : 8, y : 0, w : 52, h : 52},{ img : "char-corporate-female.png", x : -5, y : 0, w : 52, h : 52},{ img : "char-professor-male.png", x : 1, y : 3, w : 52, h : 52},{ img : "char-professor-female.png", x : 8, y : 0, w : 52, h : 52},{ img : "char-army-male.png", x : -1, y : 0, w : 52, h : 52},{ img : "char-army-female.png", x : -4, y : 0, w : 52, h : 52},{ img : "char-scientist-male.png", x : -4, y : 0, w : 52, h : 52},{ img : "char-scientist-female.png", x : -2, y : 0, w : 52, h : 52},{ img : "char-politician-male.png", x : -2, y : 0, w : 52, h : 52},{ img : "char-politician-female.png", x : 5, y : 0, w : 52, h : 52},{ img : "char-media-male.png", x : 8, y : 0, w : 52, h : 52},{ img : "char-media-female.png", x : -5, y : 0, w : 52, h : 52},{ img : "char-origin.png", x : -4, y : -10, w : 68, h : 61}];
UINode.roman = ["","I","II","III","IV","V","VI","VII","VIII","IX","X"];
sects_HarvestTask.res = [0,10,25];
sects_InvSacrificeTask.will = [0,5,10];
sects_Sect.growth = [12,8,6];
sects_Sect.taskClasses = [sects_DoNothingTask,sects_CultGeneralInfoTask,sects_CultNodeInfoTask,sects_CultResourceInfoTask,sects_CultSabotageRitualTask,sects_InvSearchTask,sects_InvConfuseTask,sects_InvSacrificeTask,sects_HarvestTask];
sects_Sect.names0 = ["Absolute","Balanced","Bare","Boundless","Caring","Clear","Eternal","Free","Fresh","Friendly","Gentle","Giving","Happy","Honest","Infinite","Innate","Noble","Open","Peaceful","Perfect","Primordial","Relaxed","Rising","Strong","Spirited","Superior","Surpassing","Tenacious","Transcendent","Unlocked","Yawning"];
sects_Sect.names1 = ["Gathering","Journey","Movement","Group","Path","Road","School","Society","Teaching","Way"];
sects_Sect.names2 = ["Ascendance","Advancement","Bliss","Care","Devotion","Embrace","Faith","Energy","Goodness","Joy","Love","Loyalty","Mind","Motion","Moon","Power","Progress","Reform","Stamina","State","Star","Stars","Sun","Vigor","Vitality","Wisdom"];
Game.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
